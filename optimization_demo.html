<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMM Trade Allocation Optimizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.8em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #2a2a4a;
            color: #fff;
            font-size: 1em;
            min-width: 120px;
        }

        .trade-types-group {
            min-width: 200px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: #2a2a4a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .checkbox-label:hover {
            border-color: #4fc3f7;
        }

        .checkbox-label input[type="checkbox"] {
            min-width: auto;
            width: 14px;
            height: 14px;
            margin: 0;
            padding: 0;
            accent-color: #4fc3f7;
        }

        .checkbox-label input[type="checkbox"]:checked + span {
            color: #4fc3f7;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.4);
        }

        .btn-secondary {
            background: #444;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Optimization Summary Section */
        .summary-section {
            background: linear-gradient(135deg, rgba(102, 187, 106, 0.15) 0%, rgba(79, 195, 247, 0.1) 100%);
            border: 1px solid rgba(102, 187, 106, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .summary-section h2 {
            color: #66bb6a;
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }

        /* Stats Panel */
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 0;
        }

        .stat-card {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card.highlight {
            background: rgba(102, 187, 106, 0.2);
            border: 1px solid rgba(102, 187, 106, 0.4);
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #4fc3f7;
            margin-bottom: 5px;
        }

        .stat-value.positive {
            color: #66bb6a;
        }

        .stat-value.negative {
            color: #ef5350;
        }

        .stat-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Methodology Section */
        .methodology-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .methodology-section h3 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .methodology-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .methodology-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #4fc3f7;
        }

        .methodology-card h4 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .methodology-card p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .methodology-card ul {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
            margin-left: 20px;
        }

        .methodology-card code {
            background: rgba(79, 195, 247, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
            color: #4fc3f7;
        }

        .greeks-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            margin-top: 10px;
        }

        .greeks-table th, .greeks-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .greeks-table th {
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.8em;
        }

        .greeks-table td {
            color: #ccc;
        }

        .greeks-table .risk-type {
            color: #4fc3f7;
            font-family: monospace;
        }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #29b6f6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .optimization-note {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(255, 167, 38, 0.1);
            border-left: 3px solid #ffa726;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ffa726;
        }

        /* Portfolio Containers */
        .portfolios-container {
            display: block;
            width: 100%;
            margin-bottom: 20px;
            min-height: 200px;
        }

        .portfolio {
            flex: 1;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 15px;
            min-height: 350px;
            position: relative;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .portfolio.highlight {
            border-color: #4fc3f7;
        }

        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .portfolio-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #4fc3f7;
        }

        .portfolio-im {
            font-size: 0.9em;
            color: #aaa;
        }

        .portfolio-im .value {
            color: #fff;
            font-weight: 600;
        }

        .trades-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 200px;
            align-content: flex-start;
        }

        /* Trade Cards */
        .trade {
            background: linear-gradient(135deg, #2d2d5a, #252550);
            border-radius: 8px;
            padding: 10px;
            width: calc(50% - 5px);
            min-width: 100px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border: 1px solid #444;
        }

        .trade:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-color: #4fc3f7;
        }

        .trade.moving {
            position: fixed;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(79, 195, 247, 0.5);
            border-color: #4fc3f7;
        }

        .trade.highlight-move {
            animation: pulse 0.5s ease-in-out;
            border-color: #66bb6a;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .trade-id {
            font-size: 0.75em;
            color: #4fc3f7;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .trade-type {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
        }

        .trade-im {
            font-size: 0.8em;
            color: #aaa;
        }

        .trade-im .value {
            color: #66bb6a;
            font-weight: 600;
        }

        /* Trade type colors */
        .trade.type-IRSwap { border-left: 3px solid #4fc3f7; }
        .trade.type-EquityOption { border-left: 3px solid #ab47bc; }
        .trade.type-FXOption { border-left: 3px solid #ffa726; }
        .trade.type-InflationSwap { border-left: 3px solid #66bb6a; }
        .trade.type-XCCYSwap { border-left: 3px solid #ef5350; }

        /* Animation Controls */
        /* Before/After Portfolio Comparison */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .comparison-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .comparison-section h3 {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .comparison-section.before h3 {
            color: #ffa726;
        }

        .comparison-section.after h3 {
            color: #66bb6a;
        }

        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .portfolio-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid;
        }

        .portfolio-card h4 {
            margin-bottom: 10px;
            font-size: 1em;
        }

        .portfolio-card .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .portfolio-card .stat-row .label {
            color: #888;
        }

        .portfolio-card .stat-row .value {
            font-weight: 600;
        }

        .portfolio-card .change {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            text-align: center;
            font-size: 0.85em;
        }

        .portfolio-card .change.positive {
            color: #66bb6a;
        }

        .portfolio-card .change.negative {
            color: #ef5350;
        }

        @media (max-width: 900px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
        }

        /* IM Chart */
        .chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 1em;
            color: #aaa;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .im-chart {
            height: 150px;
            position: relative;
            border-left: 1px solid #444;
            border-bottom: 1px solid #444;
        }

        .chart-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .chart-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #4fc3f7;
            border-radius: 50%;
            transform: translate(-50%, 50%);
            transition: all 0.3s ease;
        }

        .chart-path {
            fill: none;
            stroke: #4fc3f7;
            stroke-width: 2;
        }

        .chart-area {
            fill: rgba(79, 195, 247, 0.1);
        }

        /* Movement Log */
        .movement-log {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .movement-log h3 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .movement-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .movement-entry .arrow {
            color: #4fc3f7;
            font-weight: bold;
        }

        .movement-entry .trade-name {
            color: #fff;
            font-weight: 600;
        }

        .movement-entry .portfolio-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .portfolio-badge.from {
            background: rgba(239, 83, 80, 0.2);
            color: #ef5350;
        }

        .portfolio-badge.to {
            background: rgba(102, 187, 106, 0.2);
            color: #66bb6a;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .portfolios-container {
                flex-direction: column;
            }

            .trade {
                width: 100%;
            }
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #1a1a2e;
            border: 1px solid #4fc3f7;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.8em;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* Details Sections */
        .details-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .details-header:hover {
            background: rgba(255,255,255,0.05);
        }

        .details-header h3 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
        }

        .toggle-icon {
            color: #4fc3f7;
            font-size: 1.5em;
            font-weight: bold;
        }

        .details-content {
            padding: 0 20px 20px;
        }

        /* Risk Summary Tables */
        .risk-tables {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .risk-table-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
        }

        .risk-table-card h5 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .risk-table-card table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .risk-table-card th, .risk-table-card td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .risk-table-card th {
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.8em;
        }

        .risk-table-card td.value {
            text-align: right;
            font-family: monospace;
        }

        .risk-table-card .total-row {
            font-weight: bold;
            color: #4fc3f7;
            border-top: 2px solid #4fc3f7;
        }

        /* CRIF Table */
        .crif-section {
            margin-top: 20px;
        }

        .crif-section h4 {
            color: #aaa;
            margin-bottom: 15px;
        }

        .crif-filter {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .crif-filter label {
            color: #888;
            font-size: 0.85em;
        }

        .crif-filter select {
            padding: 6px 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a4a;
            color: #fff;
            font-size: 0.85em;
        }

        .crif-table-container {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
        }

        .crif-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        .crif-table th {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            padding: 10px 8px;
            text-align: left;
            border-bottom: 2px solid #4fc3f7;
        }

        .crif-table td {
            padding: 8px;
            border-bottom: 1px solid #333;
        }

        .crif-table tr:hover {
            background: rgba(79, 195, 247, 0.1);
        }

        .crif-table .num {
            text-align: right;
            font-family: monospace;
        }

        .crif-table .positive { color: #66bb6a; }
        .crif-table .negative { color: #ef5350; }

        /* Calculation Details */
        .calc-explanation {
            margin-bottom: 20px;
        }

        .calc-explanation h4 {
            color: #aaa;
            margin-bottom: 10px;
        }

        .formula-box {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #4fc3f7;
        }

        .formula-box p {
            margin: 8px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
        }

        .formula-note {
            color: #888;
            font-size: 0.85em !important;
            font-style: italic;
        }

        .calc-tables {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
        }

        /* Parameters Grid */
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .params-section h4 {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .params-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            overflow: hidden;
        }

        .params-table th, .params-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .params-table th {
            background: rgba(0,0,0,0.3);
            color: #888;
            font-weight: normal;
        }

        .params-table td.num {
            text-align: right;
            font-family: monospace;
            color: #4fc3f7;
        }

        .correlation-matrix {
            grid-column: span 2;
        }

        .correlation-matrix table {
            font-size: 0.8em;
        }

        .correlation-matrix td, .correlation-matrix th {
            text-align: center;
            padding: 6px;
            min-width: 60px;
        }

        .correlation-matrix .diag {
            background: rgba(79, 195, 247, 0.2);
            font-weight: bold;
        }

        .risk-summary h4, .crif-section h4 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Large dataset mode */
        .large-dataset-notice {
            background: rgba(255, 167, 38, 0.1);
            border: 1px solid #ffa726;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .large-dataset-notice .icon {
            font-size: 2em;
        }

        .large-dataset-notice .text {
            flex: 1;
        }

        .large-dataset-notice .text h4 {
            color: #ffa726;
            margin-bottom: 5px;
        }

        .large-dataset-notice .text p {
            color: #aaa;
            font-size: 0.9em;
            margin: 0;
        }

        /* Summary view for large datasets */
        .portfolio-summary {
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .portfolio-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .portfolio-summary-header h4 {
            color: #4fc3f7;
            margin: 0;
        }

        .portfolio-summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .summary-stat {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .summary-stat .value {
            font-size: 1.3em;
            font-weight: bold;
            color: #4fc3f7;
        }

        .summary-stat .label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .trade-type-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .trade-type-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            background: rgba(79, 195, 247, 0.1);
            color: #4fc3f7;
        }

        /* Animation progress for large datasets */
        .optimization-running {
            text-align: center;
            padding: 40px;
        }

        .optimization-running .big-spinner {
            border: 4px solid #333;
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .optimization-running h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }

        .optimization-running p {
            color: #888;
        }

        .live-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .live-stat {
            text-align: center;
        }

        .live-stat .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .live-stat .label {
            font-size: 0.8em;
            color: #888;
        }

        /* Chart marker for current iteration */
        #chartMarker {
            filter: drop-shadow(0 0 4px rgba(255, 167, 38, 0.8));
            transition: all 0.15s ease;
        }

        /* Highlight completed state */
        .portfolio-summary.completed {
            animation: pulse-green 0.5s ease;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px rgba(102, 187, 106, 0.5); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SIMM Trade Allocation Optimizer</h1>
        <p class="subtitle">Minimize Initial Margin through optimal portfolio allocation • JavaScript demo with synthetic data</p>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-group">
                <label>Number of Trades</label>
                <input type="number" id="numTrades" min="3" max="10000" value="10">
            </div>
            <div class="control-group">
                <label>Portfolios</label>
                <input type="number" id="numPortfolios" min="2" max="20" value="3">
            </div>
            <div class="control-group">
                <label>Avg Maturity (Y)</label>
                <input type="number" id="avgMaturity" min="0.5" max="30" step="0.5" value="5">
            </div>
            <div class="control-group">
                <label>Maturity Spread (Y)</label>
                <input type="number" id="maturitySpread" min="0" max="10" step="0.5" value="1">
            </div>
            <div class="control-group trade-types-group">
                <label>Trade Types</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="type_ir_swap" value="ir_swap" checked>
                        <span>IR Swap</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="type_equity_option" value="equity_option">
                        <span>Equity Option</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="type_fx_option" value="fx_option">
                        <span>FX Option</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="type_inflation_swap" value="inflation_swap">
                        <span>Inflation Swap</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="type_xccy_swap" value="xccy_swap">
                        <span>XCCY Swap</span>
                    </label>
                </div>
            </div>
            <button class="btn btn-primary" id="runOptimization">
                Run Optimization
            </button>
            <button class="btn btn-secondary" id="loadSample">
                Load Sample Data
            </button>
        </div>

        <!-- Optimization Summary Section (at top) -->
        <div class="summary-section" id="summarySection">
            <h2>Optimization Summary</h2>
            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-value" id="initialIM">-</div>
                    <div class="stat-label">Initial Total IM</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="finalIM">-</div>
                    <div class="stat-label">Final Total IM</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value positive" id="reduction">-</div>
                    <div class="stat-label">IM Reduction</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value positive" id="totalSavings">-</div>
                    <div class="stat-label">Total Savings</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="tradesMoved">-</div>
                    <div class="stat-label">Trades Moved</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="iterations">-</div>
                    <div class="stat-label">Iterations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="execTime">-</div>
                    <div class="stat-label">Execution Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="maturityInfo">-</div>
                    <div class="stat-label">Avg Maturity</div>
                </div>
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-header">
                <span>Optimization Progress</span>
                <span id="progressText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div id="optimizationNote" class="optimization-note" style="display: none;">
                Note: Real optimization uses continuous allocation fractions. IM may change before trades visually move.
            </div>
        </div>


        <!-- Before/After Portfolio Comparison Section -->
        <div class="details-section" style="padding: 20px;">
            <h3 style="color: #aaa; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 15px;">Portfolio Comparison: Before vs After</h3>
            <div class="portfolios-container" id="portfoliosContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Configure parameters and click "Run Optimization" or "Load Sample Data"</p>
                </div>
            </div>
        </div>

        <!-- IM Chart -->
        <div class="chart-container">
            <div class="chart-title">Total IM Over Iterations</div>
            <svg class="im-chart" id="imChart" viewBox="0 0 800 150" preserveAspectRatio="none">
                <path class="chart-area" id="chartArea"></path>
                <path class="chart-path" id="chartPath"></path>
            </svg>
        </div>

        <!-- Movement Log -->
        <div class="movement-log">
            <h3>Trade Movements</h3>
            <div id="movementLog">
                <p style="color: #666;">No movements yet</p>
            </div>
        </div>

        <!-- CRIF & Calculation Details -->
        <div class="details-section">
            <div class="details-header" onclick="toggleDetails('crifDetails')">
                <h3>CRIF Sensitivities & Risk Breakdown</h3>
                <span class="toggle-icon" id="crifDetailsIcon">+</span>
            </div>
            <div class="details-content" id="crifDetails" style="display: none;">
                <!-- Risk Class Summary -->
                <div class="risk-summary">
                    <h4>Portfolio Risk Class Breakdown</h4>
                    <div class="risk-tables" id="riskTables"></div>
                </div>

                <!-- Trade CRIF Details -->
                <div class="crif-section">
                    <h4>Trade Sensitivities (CRIF Format)</h4>
                    <div class="crif-filter">
                        <label>Filter by Trade:</label>
                        <select id="crifTradeFilter" onchange="filterCRIF()">
                            <option value="all">All Trades</option>
                        </select>
                        <label style="margin-left: 15px;">Filter by Risk Type:</label>
                        <select id="crifRiskFilter" onchange="filterCRIF()">
                            <option value="all">All Risk Types</option>
                        </select>
                    </div>
                    <div class="crif-table-container">
                        <table class="crif-table" id="crifTable">
                            <thead>
                                <tr>
                                    <th>TradeID</th>
                                    <th>RiskType</th>
                                    <th>Qualifier</th>
                                    <th>Bucket</th>
                                    <th>Label1</th>
                                    <th>Amount</th>
                                    <th>RiskWeight</th>
                                    <th>Weighted</th>
                                </tr>
                            </thead>
                            <tbody id="crifTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- IM Calculation Details -->
        <div class="details-section">
            <div class="details-header" onclick="toggleDetails('calcDetails')">
                <h3>IM Calculation Breakdown</h3>
                <span class="toggle-icon" id="calcDetailsIcon">+</span>
            </div>
            <div class="details-content" id="calcDetails" style="display: none;">
                <div class="calc-explanation">
                    <h4>ISDA SIMM v2.6 Formula (with intra-bucket correlations)</h4>
                    <div class="formula-box">
                        <p><strong>Per Risk Class:</strong> K<sub>r</sub> = √(Σ<sub>i,j</sub> <span style="color:#4fc3f7">ρ<sub>ij</sub></span> × WS<sub>i</sub> × WS<sub>j</sub>)</p>
                        <p><strong>Total IM:</strong> IM = √(Σ<sub>r,s</sub> ψ<sub>rs</sub> × K<sub>r</sub> × K<sub>s</sub>)</p>
                        <p class="formula-note">where WS<sub>i</sub> = w<sub>i</sub> × s<sub>i</sub> (weighted sensitivity), <span style="color:#4fc3f7">ρ<sub>ij</sub></span> = intra-bucket correlation, ψ<sub>rs</sub> = cross-risk-class correlation</p>
                        <p class="formula-note" style="margin-top:8px;font-size:0.85em;color:#888;">
                            <strong>Correlations:</strong> IR uses 12×12 tenor matrix (e.g., ρ(5Y,10Y)=0.95). Same-sign positions increase K; opposite-sign positions offset.
                            <br><strong>Currency weights:</strong> USD/EUR use regular weights; JPY uses low-vol weights (~40% lower); BRL uses high-vol weights (~50% higher).
                        </p>
                    </div>
                </div>
                <div class="calc-tables" id="calcTables"></div>
            </div>
        </div>

        <!-- Correlation Matrix -->
        <div class="details-section">
            <div class="details-header" onclick="toggleDetails('corrDetails')">
                <h3>SIMM Parameters (Risk Weights & Correlations)</h3>
                <span class="toggle-icon" id="corrDetailsIcon">+</span>
            </div>
            <div class="details-content" id="corrDetails" style="display: none;">
                <div class="params-grid">
                    <div class="params-section">
                        <h4>IR Risk Weights by Tenor</h4>
                        <table class="params-table">
                            <thead><tr><th>Tenor</th><th>Weight</th></tr></thead>
                            <tbody id="irWeightsTable"></tbody>
                        </table>
                    </div>
                    <div class="params-section">
                        <h4>Other Risk Weights</h4>
                        <table class="params-table">
                            <thead><tr><th>Risk Type</th><th>Weight</th></tr></thead>
                            <tbody id="otherWeightsTable"></tbody>
                        </table>
                    </div>
                    <div class="params-section correlation-matrix">
                        <h4>Cross-Risk-Class Correlations (ψ)</h4>
                        <table class="params-table" id="correlationMatrix"></table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Methodology Section -->
        <div class="methodology-section">
            <h3>How It Works: ISDA SIMM Optimization</h3>
            <div class="methodology-grid">
                <div class="methodology-card">
                    <h4>ISDA SIMM v2.6</h4>
                    <p>The Standard Initial Margin Model (SIMM) is a risk-based methodology for calculating initial margin requirements for non-cleared derivatives.</p>
                    <p>The margin captures Delta, Vega, and Curvature risk across six risk classes: Rates, CreditQ, CreditNonQ, Equity, Commodity, and FX.</p>
                </div>
                <div class="methodology-card">
                    <h4>Why Allocation Matters</h4>
                    <p>Random allocation splits natural hedges across portfolios, eliminating netting benefits:</p>
                    <ul>
                        <li>Pay-fixed swap in Portfolio 1</li>
                        <li>Receive-fixed swap in Portfolio 2</li>
                        <li>No netting → Higher total IM</li>
                    </ul>
                    <p style="margin-top: 10px;">Optimal allocation groups offsetting positions in the same portfolio, achieving <strong>10-30% IM reduction</strong>.</p>
                </div>
                <div class="methodology-card">
                    <h4>Netting Model</h4>
                    <p>The SIMM formula captures netting through signed sensitivities:</p>
                    <p style="font-family: monospace; color: #4fc3f7; margin: 10px 0;">
                        IM ≈ α × |Σ sensitivities| + β × √(Σ sens²)
                    </p>
                    <p>When opposite sensitivities are grouped:</p>
                    <ul>
                        <li>|netted| → 0 (cancellation)</li>
                        <li>Portfolio IM decreases significantly</li>
                    </ul>
                </div>
                <div class="methodology-card">
                    <h4>When AADC is Used</h4>
                    <p><strong>This demo</strong> uses JavaScript simulation with synthetic data for visualization.</p>
                    <p style="margin-top: 8px;"><strong>The Python implementation</strong> uses AADC for:</p>
                    <ul style="margin-top: 5px;">
                        <li><strong>Greek computation</strong>: Single forward + adjoint pass instead of bump-and-revalue (20x speedup)</li>
                        <li><strong>Allocation gradients</strong>: ∂IM/∂x[t,p] via chain rule with small O(K) kernel</li>
                        <li><strong>CRIF generation</strong>: Automatic sensitivity extraction from trade pricing</li>
                    </ul>
                    <p style="margin-top: 8px; font-size: 0.85em; color: #888;">Run <code>python -m model.simm_portfolio_aadc --optimize</code> for real AADC optimization.</p>
                </div>
                <div class="methodology-card" style="grid-column: span 2;">
                    <h4>Supported Greeks</h4>
                    <table class="greeks-table">
                        <thead>
                            <tr>
                                <th>Greek Type</th>
                                <th>Risk Type</th>
                                <th>Description</th>
                                <th>Trade Types</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_IRCurve</td>
                                <td>Interest rate delta by tenor bucket</td>
                                <td>IR Swaps, FX Options, Inflation Swaps, XCCY Swaps</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_FX</td>
                                <td>FX spot delta</td>
                                <td>FX Options, XCCY Swaps</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_Equity</td>
                                <td>Equity spot delta</td>
                                <td>Equity Options</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_Inflation</td>
                                <td>Inflation rate delta</td>
                                <td>Inflation Swaps</td>
                            </tr>
                            <tr>
                                <td>Vega</td>
                                <td class="risk-type">Risk_EquityVol</td>
                                <td>Equity implied volatility sensitivity</td>
                                <td>Equity Options</td>
                            </tr>
                            <tr>
                                <td>Vega</td>
                                <td class="risk-type">Risk_FXVol</td>
                                <td>FX implied volatility sensitivity</td>
                                <td>FX Options</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // SIMM Parameters (ISDA v2.6) - Now with intra-bucket correlations
        const SIMM_PARAMS = {
            version: '2.6',
            irTenors: ['2W', '1M', '3M', '6M', '1Y', '2Y', '3Y', '5Y', '10Y', '15Y', '20Y', '30Y'],
            // Currency-specific IR risk weights (regular volatility currencies)
            irWeights: {
                'regular': [77, 77, 68, 56, 52, 50, 51, 52, 50, 51, 51, 64],
                'low': [15, 19, 9, 11, 15, 22, 22, 23, 21, 19, 20, 23],      // JPY, etc.
                'high': [116, 116, 107, 93, 87, 91, 92, 97, 102, 101, 106, 101] // BRL, etc.
            },
            lowVolCurrencies: ['JPY'],
            highVolCurrencies: ['BRL', 'TRY', 'ZAR', 'MXN', 'RUB'],
            // IR tenor correlation matrix (12x12) - ISDA v2.6
            irCorrelation: [
                [1.00, 0.99, 0.94, 0.87, 0.77, 0.67, 0.61, 0.52, 0.41, 0.35, 0.29, 0.20],
                [0.99, 1.00, 0.97, 0.91, 0.81, 0.72, 0.66, 0.58, 0.47, 0.40, 0.34, 0.25],
                [0.94, 0.97, 1.00, 0.97, 0.90, 0.82, 0.76, 0.68, 0.56, 0.49, 0.42, 0.32],
                [0.87, 0.91, 0.97, 1.00, 0.96, 0.90, 0.85, 0.77, 0.65, 0.57, 0.50, 0.39],
                [0.77, 0.81, 0.90, 0.96, 1.00, 0.97, 0.94, 0.87, 0.76, 0.68, 0.60, 0.48],
                [0.67, 0.72, 0.82, 0.90, 0.97, 1.00, 0.98, 0.94, 0.85, 0.77, 0.69, 0.56],
                [0.61, 0.66, 0.76, 0.85, 0.94, 0.98, 1.00, 0.97, 0.90, 0.83, 0.75, 0.62],
                [0.52, 0.58, 0.68, 0.77, 0.87, 0.94, 0.97, 1.00, 0.95, 0.90, 0.83, 0.70],
                [0.41, 0.47, 0.56, 0.65, 0.76, 0.85, 0.90, 0.95, 1.00, 0.97, 0.93, 0.82],
                [0.35, 0.40, 0.49, 0.57, 0.68, 0.77, 0.83, 0.90, 0.97, 1.00, 0.98, 0.89],
                [0.29, 0.34, 0.42, 0.50, 0.60, 0.69, 0.75, 0.83, 0.93, 0.98, 1.00, 0.94],
                [0.20, 0.25, 0.32, 0.39, 0.48, 0.56, 0.62, 0.70, 0.82, 0.89, 0.94, 1.00]
            ],
            otherWeights: {
                'FX': 8.4,
                'FX Vol': 4.6,
                'Equity': 25.0,
                'Equity Vol': 28.0,
                'Inflation': 63.0,
                'Credit': 85.0,
                'Commodity': 40.0
            },
            // Intra-bucket correlations for other risk classes
            intraCorrelations: {
                'Equity': 0.25,
                'Commodity': 0.50,
                'FX': 0.50,
                'CreditQ': 0.50,
                'CreditNonQ': 0.50
            },
            riskClasses: ['Rates', 'CreditQ', 'CreditNonQ', 'Equity', 'Commodity', 'FX'],
            psiMatrix: [
                [1.00, 0.04, 0.04, 0.07, 0.37, 0.14],
                [0.04, 1.00, 0.54, 0.70, 0.27, 0.37],
                [0.04, 0.54, 1.00, 0.46, 0.24, 0.15],
                [0.07, 0.70, 0.46, 1.00, 0.35, 0.39],
                [0.37, 0.27, 0.24, 0.35, 1.00, 0.35],
                [0.14, 0.37, 0.15, 0.39, 0.35, 1.00]
            ]
        };

        // Get IR risk weight based on currency volatility bucket
        function getIRRiskWeight(currency, tenorIdx) {
            if (SIMM_PARAMS.lowVolCurrencies.includes(currency)) {
                return SIMM_PARAMS.irWeights.low[tenorIdx];
            } else if (SIMM_PARAMS.highVolCurrencies.includes(currency)) {
                return SIMM_PARAMS.irWeights.high[tenorIdx];
            }
            return SIMM_PARAMS.irWeights.regular[tenorIdx];
        }

        // Get IR tenor correlation
        function getIRCorrelation(tenorIdx1, tenorIdx2) {
            return SIMM_PARAMS.irCorrelation[tenorIdx1][tenorIdx2];
        }

        // Global state
        let demoData = null;
        const LARGE_DATASET_THRESHOLD = 100; // Show extra loading message for large datasets
        // Track execution time
        let lastExecutionTime = 0;

        // DOM elements
        const portfoliosContainer = document.getElementById('portfoliosContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const movementLog = document.getElementById('movementLog');
        const tooltip = document.getElementById('tooltip');

        // Format currency
        function formatCurrency(value) {
            if (value >= 1e9) {
                return '$' + (value / 1e9).toFixed(2) + 'B';
            } else if (value >= 1e6) {
                return '$' + (value / 1e6).toFixed(2) + 'M';
            } else if (value >= 1e3) {
                return '$' + (value / 1e3).toFixed(2) + 'K';
            }
            return '$' + value.toFixed(2);
        }

        // Format percentage
        function formatPercent(value) {
            return value.toFixed(1) + '%';
        }

        // Map checkbox values to display names
        const tradeTypeMap = {
            'ir_swap': 'IRSwap',
            'equity_option': 'EquityOption',
            'fx_option': 'FXOption',
            'inflation_swap': 'InflationSwap',
            'xccy_swap': 'XCCYSwap'
        };

        // Sample data generator (for demo without backend)
        function generateSampleData(numTrades, numPortfolios, avgMaturity = null, maturitySpread = null) {
            // Get parameters from inputs if not provided
            if (avgMaturity === null) {
                avgMaturity = parseFloat(document.getElementById('avgMaturity').value) || 5;
            }
            if (maturitySpread === null) {
                maturitySpread = parseFloat(document.getElementById('maturitySpread').value) || 1;
            }

            // Get selected trade types
            const selectedTypes = getSelectedTradeTypes().split(',').map(t => tradeTypeMap[t] || 'IRSwap');
            const tradeTypes = selectedTypes.length > 0 ? selectedTypes : ['IRSwap'];
            const currencies = ['USD', 'EUR', 'GBP', 'JPY'];

            const trades = [];
            const padWidth = Math.max(3, String(numTrades).length);
            for (let i = 0; i < numTrades; i++) {
                // Generate maturity around the average with specified spread
                const minMat = Math.max(0.25, avgMaturity - maturitySpread);
                const maxMat = Math.min(30, avgMaturity + maturitySpread);
                const maturity = minMat + Math.random() * (maxMat - minMat);

                // Generate SIGNED sensitivity for netting - key for realistic optimization
                // ~50% positive (pay fixed/long), ~50% negative (receive fixed/short)
                const direction = Math.random() > 0.5 ? 1 : -1;
                const baseSens = (Math.random() * 5000000000 + 100000000) * direction;

                trades.push({
                    id: `TRADE_${String(i).padStart(padWidth, '0')}`,
                    type: tradeTypes[Math.floor(Math.random() * tradeTypes.length)],
                    notional: Math.random() * 100000000 + 10000000,
                    currency: currencies[Math.floor(Math.random() * currencies.length)],
                    maturity: maturity,
                    sensitivity: baseSens,  // Signed sensitivity for netting
                    standalone_im: Math.abs(baseSens),  // Standalone IM is absolute
                    initial_portfolio: Math.floor(Math.random() * numPortfolios),
                    num_sensitivities: Math.floor(Math.random() * 20) + 5,
                });
            }

            // Generate optimization steps - IM only changes when trades move
            const steps = [];
            let currentAssignments = trades.map(t => t.initial_portfolio);

            // OPTIMIZED: Pre-compute portfolio aggregates for O(1) IM updates
            // Track both signed sensitivity sum (for netting) and absolute sum (for standalone)
            const portfolioSums = new Array(numPortfolios).fill(0).map(() => ({
                sensSum: 0,      // Sum of signed sensitivities (can net to zero)
                absSum: 0,       // Sum of absolute sensitivities (standalone total)
                sqSum: 0,        // Sum of squared sensitivities
                count: 0
            }));
            for (let t = 0; t < numTrades; t++) {
                const p = currentAssignments[t];
                const sens = trades[t].sensitivity;
                portfolioSums[p].sensSum += sens;
                portfolioSums[p].absSum += Math.abs(sens);
                portfolioSums[p].sqSum += sens * sens;
                portfolioSums[p].count++;
            }

            // Calculate IM using SIMM-like netting model
            // Key insight: IM = sqrt(sum of squares) with correlation benefit
            // When opposite sensitivities are grouped, they partially cancel
            function calcTotalIMFast() {
                let total = 0;
                for (let p = 0; p < numPortfolios; p++) {
                    if (portfolioSums[p].count === 0) continue;
                    // SIMM-like formula: blend of netted and gross
                    // - |sensSum| captures netting benefit (opposite signs cancel)
                    // - sqrt(sqSum) captures diversification
                    // - absSum is the no-netting baseline
                    const netted = Math.abs(portfolioSums[p].sensSum);
                    const diversified = Math.sqrt(portfolioSums[p].sqSum);
                    // Use 40% netted + 60% diversified - realistic SIMM-like blend
                    const portfolioIM = 0.4 * netted + 0.6 * diversified;
                    total += portfolioIM;
                }
                return total;
            }

            // Update sums when moving a trade - O(1)
            function moveTrade(tradeIdx, fromP, toP) {
                const sens = trades[tradeIdx].sensitivity;
                const absSens = Math.abs(sens);
                portfolioSums[fromP].sensSum -= sens;
                portfolioSums[fromP].absSum -= absSens;
                portfolioSums[fromP].sqSum -= sens * sens;
                portfolioSums[fromP].count--;
                portfolioSums[toP].sensSum += sens;
                portfolioSums[toP].absSum += absSens;
                portfolioSums[toP].sqSum += sens * sens;
                portfolioSums[toP].count++;
            }

            let totalIM = calcTotalIMFast();
            const initialIM = totalIM;
            const totalSteps = 30;

            // For large datasets, use sign-based clustering optimization
            // Key insight: netting benefits come from grouping opposite-sign trades
            // Strategy: designate some portfolios for positive sens, others for negative

            if (numTrades > 1000) {
                // LARGE DATASET OPTIMIZATION
                // Key insight: netting benefit comes from PAIRING opposite-sign trades
                // IM = 0.4 * |sensSum| + 0.6 * sqrt(sqSum)
                // When opposite signs cancel, |sensSum| → 0, reducing IM

                // Phase 1: Pair positive and negative trades for maximum netting
                // Sort trades by sensitivity (most negative to most positive)
                const sortedTrades = trades.map((t, i) => ({
                    idx: i,
                    sens: t.sensitivity
                })).sort((a, b) => a.sens - b.sens);

                // Pair from both ends: most negative with most positive
                // Assign paired trades to same portfolio for cancellation
                const numPairs = Math.floor(sortedTrades.length / 2);
                for (let i = 0; i < numPairs; i++) {
                    const negTrade = sortedTrades[i].idx;
                    const posTrade = sortedTrades[sortedTrades.length - 1 - i].idx;
                    const targetPortfolio = i % numPortfolios;

                    // Move negative trade
                    const oldPNeg = currentAssignments[negTrade];
                    if (oldPNeg !== targetPortfolio) {
                        moveTrade(negTrade, oldPNeg, targetPortfolio);
                        currentAssignments[negTrade] = targetPortfolio;
                    }

                    // Move positive trade to same portfolio
                    const oldPPos = currentAssignments[posTrade];
                    if (oldPPos !== targetPortfolio) {
                        moveTrade(posTrade, oldPPos, targetPortfolio);
                        currentAssignments[posTrade] = targetPortfolio;
                    }
                }

                // Handle odd trade if any
                if (sortedTrades.length % 2 === 1) {
                    const midTrade = sortedTrades[numPairs].idx;
                    // Leave in current portfolio or assign to least loaded
                }

                const afterClusteringIM = calcTotalIMFast();

                // Record clustering phase
                for (let s = 0; s < 15; s++) {
                    const progress = s / 14;
                    steps.push({
                        iteration: s,
                        total_im: initialIM + (afterClusteringIM - initialIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }
                totalIM = afterClusteringIM;

                // Phase 2: Fine-tuning with greedy moves on high-impact trades
                const tradesByImpact = trades.map((t, i) => ({
                    idx: i,
                    absSens: Math.abs(t.sensitivity)
                })).sort((a, b) => b.absSens - a.absSens);

                const fineTuneTrades = tradesByImpact.slice(0, Math.min(1000, numTrades)).map(t => t.idx);

                fineTuneTrades.forEach(t => {
                    const currentP = currentAssignments[t];
                    let bestP = currentP;
                    let bestIM = totalIM;

                    for (let p = 0; p < numPortfolios; p++) {
                        if (p === currentP) continue;
                        moveTrade(t, currentP, p);
                        const newIM = calcTotalIMFast();
                        if (newIM < bestIM) {
                            bestIM = newIM;
                            bestP = p;
                        }
                        moveTrade(t, p, currentP);
                    }

                    if (bestP !== currentP && bestIM < totalIM) {
                        moveTrade(t, currentP, bestP);
                        currentAssignments[t] = bestP;
                        totalIM = bestIM;
                    }
                });

                // Record fine-tuning phase
                const afterFineTuneIM = totalIM;
                for (let s = 15; s < totalSteps; s++) {
                    const progress = (s - 15) / (totalSteps - 15);
                    steps.push({
                        iteration: s,
                        total_im: afterClusteringIM + (afterFineTuneIM - afterClusteringIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }

            } else {
                // SMALL DATASET OPTIMIZATION - original greedy approach
                const tradesByImpact = trades.map((t, i) => ({
                    idx: i,
                    absSens: Math.abs(t.sensitivity)
                })).sort((a, b) => b.absSens - a.absSens);

                const maxTradesToEvaluate = Math.min(numTrades, 500);
                const tradeIndicesToEvaluate = tradesByImpact
                    .slice(0, maxTradesToEvaluate)
                    .map(t => t.idx);

                // Multiple greedy passes
                for (let pass = 0; pass < 3; pass++) {
                    tradeIndicesToEvaluate.forEach(t => {
                        const currentP = currentAssignments[t];
                        let bestP = currentP;
                        let bestIM = totalIM;

                        for (let p = 0; p < numPortfolios; p++) {
                            if (p === currentP) continue;
                            moveTrade(t, currentP, p);
                            const newIM = calcTotalIMFast();
                            if (newIM < bestIM) {
                                bestIM = newIM;
                                bestP = p;
                            }
                            moveTrade(t, p, currentP);
                        }

                        if (bestP !== currentP && bestIM < totalIM) {
                            moveTrade(t, currentP, bestP);
                            currentAssignments[t] = bestP;
                            totalIM = bestIM;
                        }
                    });
                }

                // Record steps
                for (let s = 0; s < totalSteps; s++) {
                    const progress = s / (totalSteps - 1);
                    steps.push({
                        iteration: s,
                        total_im: initialIM + (totalIM - initialIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }
            }

            // Calculate portfolio IMs - using same netting model as optimization
            function calcPortfolioIMs(assignments) {
                // Build sums per portfolio in O(T)
                const pData = new Array(numPortfolios).fill(0).map(() => ({
                    sensSum: 0, sqSum: 0, count: 0
                }));
                for (let t = 0; t < numTrades; t++) {
                    const p = assignments[t];
                    const sens = trades[t].sensitivity;
                    pData[p].sensSum += sens;
                    pData[p].sqSum += sens * sens;
                    pData[p].count++;
                }

                const portfolioIMs = [];
                for (let p = 0; p < numPortfolios; p++) {
                    // Same SIMM-like formula as optimization
                    const netted = Math.abs(pData[p].sensSum);
                    const diversified = Math.sqrt(pData[p].sqSum);
                    const portfolioIM = 0.4 * netted + 0.6 * diversified;
                    portfolioIMs.push({
                        portfolio: p,
                        im: portfolioIM,
                        trades: pData[p].count,
                    });
                }
                return portfolioIMs;
            }

            const initialAssignments = trades.map(t => t.initial_portfolio);
            const finalAssignments = steps[steps.length - 1].assignments;

            // Find movements
            const movements = [];
            for (let i = 0; i < numTrades; i++) {
                if (initialAssignments[i] !== finalAssignments[i]) {
                    movements.push({
                        trade_id: trades[i].id,
                        from_portfolio: initialAssignments[i],
                        to_portfolio: finalAssignments[i],
                        standalone_im: trades[i].standalone_im,
                    });
                }
            }

            const initialPortfolioIMs = calcPortfolioIMs(initialAssignments);
            const finalPortfolioIMs = calcPortfolioIMs(finalAssignments);
            const initialTotalIM = initialPortfolioIMs.reduce((s, p) => s + p.im, 0);
            const finalTotalIM = finalPortfolioIMs.reduce((s, p) => s + p.im, 0);

            // Compute maturity stats
            const maturities = trades.map(t => t.maturity);
            const actualAvgMaturity = maturities.reduce((a, b) => a + b, 0) / maturities.length;
            const minMaturity = Math.min(...maturities);
            const maxMaturity = Math.max(...maturities);

            return {
                config: {
                    num_trades: numTrades,
                    num_portfolios: numPortfolios,
                    trade_types: 'Mixed',
                    num_risk_factors: Math.floor(Math.random() * 30) + 10,
                    avg_maturity: Math.round(actualAvgMaturity * 100) / 100,
                    maturity_range: [Math.round(minMaturity * 100) / 100, Math.round(maxMaturity * 100) / 100],
                },
                trades: trades,
                initial_state: {
                    assignments: initialAssignments,
                    portfolio_ims: initialPortfolioIMs,
                    total_im: initialTotalIM,
                },
                final_state: {
                    assignments: finalAssignments,
                    portfolio_ims: finalPortfolioIMs,
                    total_im: finalTotalIM,
                },
                optimization: {
                    num_iterations: steps.length,
                    steps: steps,
                    movements: movements,
                    im_reduction_pct: (1 - finalTotalIM / initialTotalIM) * 100,
                },
            };
        }

        // Track if using real backend (continuous optimization)
        let isRealBackend = false;

        // Initialize visualization with data
        function initializeVisualization(data, fromBackend = false, execTime = 0) {
            demoData = data;
            isRealBackend = fromBackend;
            lastExecutionTime = execTime;

            // Show/hide optimization note
            document.getElementById('optimizationNote').style.display = fromBackend ? 'block' : 'none';

            // Update stats
            const totalSavings = data.initial_state.total_im - data.final_state.total_im;
            document.getElementById('initialIM').textContent = formatCurrency(data.initial_state.total_im);
            document.getElementById('finalIM').textContent = formatCurrency(data.final_state.total_im);
            document.getElementById('reduction').textContent = formatPercent(data.optimization.im_reduction_pct);
            document.getElementById('totalSavings').textContent = formatCurrency(totalSavings);
            document.getElementById('tradesMoved').textContent = data.optimization.movements.length;
            document.getElementById('iterations').textContent = data.optimization.num_iterations;
            document.getElementById('execTime').textContent = execTime.toFixed(2) + 's';

            // Display maturity info
            if (data.config.avg_maturity !== undefined) {
                const range = data.config.maturity_range || [data.config.avg_maturity, data.config.avg_maturity];
                document.getElementById('maturityInfo').textContent = `${data.config.avg_maturity.toFixed(1)}Y`;
                document.getElementById('maturityInfo').title = `Range: ${range[0].toFixed(1)}Y - ${range[1].toFixed(1)}Y`;
            }

            // Show progress bar at 100%
            progressFill.style.width = '100%';
            progressText.textContent = `Completed - ${data.optimization.num_iterations} iterations`;

            // Create before/after comparison view
            createBeforeAfterView(data);

            // Update chart
            updateChart(data);

            // Populate CRIF and calculation details
            populateCRIFDetails(data);

            // Update movement log
            updateMovementLog(data.optimization.movements);
        }

        // Create before/after portfolio comparison view
        function createBeforeAfterView(data) {
            const colors = ['#4fc3f7', '#ab47bc', '#ffa726', '#66bb6a', '#ef5350'];
            const numPortfolios = data.config.num_portfolios;

            // Pre-compute trade type counts per portfolio for both states
            const beforeTypeCounts = {};
            const afterTypeCounts = {};
            for (let p = 0; p < numPortfolios; p++) {
                beforeTypeCounts[p] = {};
                afterTypeCounts[p] = {};
            }
            data.trades.forEach((t, i) => {
                const beforeP = data.initial_state.assignments[i];
                const afterP = data.final_state.assignments[i];
                beforeTypeCounts[beforeP][t.type] = (beforeTypeCounts[beforeP][t.type] || 0) + 1;
                afterTypeCounts[afterP][t.type] = (afterTypeCounts[afterP][t.type] || 0) + 1;
            });

            let html = `
                <div class="comparison-container">
                    <div class="comparison-section before">
                        <h3>BEFORE Optimization</h3>
                        <div class="total-im">Total IM: ${formatCurrency(data.initial_state.total_im)}</div>
                        <div class="portfolio-grid">
            `;

            // Before portfolios
            for (let p = 0; p < numPortfolios; p++) {
                const pData = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const typeStr = Object.entries(beforeTypeCounts[p])
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ') || 'No trades';

                html += `
                    <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                        <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                        <div class="stat-row">
                            <span class="label">Trades</span>
                            <span class="value">${pData.trades}</span>
                        </div>
                        <div class="stat-row">
                            <span class="label">IM</span>
                            <span class="value">${formatCurrency(pData.im)}</span>
                        </div>
                        <div class="stat-row" style="font-size: 0.8em; color: #666;">
                            ${typeStr}
                        </div>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                    <div class="comparison-section after">
                        <h3>AFTER Optimization</h3>
                        <div class="total-im">Total IM: ${formatCurrency(data.final_state.total_im)}</div>
                        <div class="portfolio-grid">
            `;

            // After portfolios with change indicators
            for (let p = 0; p < numPortfolios; p++) {
                const beforeData = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const afterData = data.final_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const typeStr = Object.entries(afterTypeCounts[p])
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ') || 'No trades';

                const imChange = afterData.im - beforeData.im;
                const tradeChange = afterData.trades - beforeData.trades;
                const imChangeClass = imChange <= 0 ? 'positive' : 'negative';
                const tradeChangeStr = tradeChange > 0 ? `+${tradeChange}` : tradeChange.toString();

                html += `
                    <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                        <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                        <div class="stat-row">
                            <span class="label">Trades</span>
                            <span class="value">${afterData.trades} <span style="color: #888; font-size: 0.85em;">(${tradeChangeStr})</span></span>
                        </div>
                        <div class="stat-row">
                            <span class="label">IM</span>
                            <span class="value">${formatCurrency(afterData.im)}</span>
                        </div>
                        <div class="stat-row" style="font-size: 0.8em; color: #666;">
                            ${typeStr}
                        </div>
                        <div class="change ${imChangeClass}">
                            ${imChange <= 0 ? '▼' : '▲'} ${formatCurrency(Math.abs(imChange))}
                        </div>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                </div>
            `;

            // Note: Summary is now at the top of the page (in the summary-section)

            portfoliosContainer.innerHTML = html;
        }

        // Create summary view for large datasets
        function createPortfolioSummaryView(data) {
            const colors = ['#4fc3f7', '#ab47bc', '#ffa726', '#66bb6a', '#ef5350'];
            let html = '';

            // Large dataset notice
            html += `
                <div class="large-dataset-notice">
                    <div class="icon">📊</div>
                    <div class="text">
                        <h4>Large Dataset Mode</h4>
                        <p>${data.config.num_trades} trades across ${data.config.num_portfolios} portfolios.
                           Individual trade animations disabled for performance.
                           See summary below and detailed breakdown in collapsible sections.</p>
                    </div>
                </div>
            `;

            // Pre-compute trade type counts per portfolio in O(T) instead of O(T×P)
            const typeCountByPortfolio = {};
            for (let p = 0; p < data.config.num_portfolios; p++) {
                typeCountByPortfolio[p] = {};
            }
            data.trades.forEach((t, i) => {
                const p = data.final_state.assignments[i];
                typeCountByPortfolio[p][t.type] = (typeCountByPortfolio[p][t.type] || 0) + 1;
            });

            // Summary for each portfolio - comparing initial vs final
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">';

            for (let p = 0; p < data.config.num_portfolios; p++) {
                const initialP = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const finalP = data.final_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};

                const typeCount = typeCountByPortfolio[p];

                const imChange = finalP.im - initialP.im;
                const imChangeClass = imChange <= 0 ? 'positive' : 'negative';
                const tradesChange = finalP.trades - initialP.trades;
                const tradesChangeStr = tradesChange > 0 ? `+${tradesChange}` : tradesChange.toString();

                html += `
                    <div class="portfolio-summary">
                        <div class="portfolio-summary-header">
                            <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                            <span style="color: #888;">Final State</span>
                        </div>
                        <div class="portfolio-summary-stats">
                            <div class="summary-stat">
                                <div class="value">${finalP.trades}</div>
                                <div class="label">Trades (${tradesChangeStr})</div>
                            </div>
                            <div class="summary-stat">
                                <div class="value">${formatCurrency(finalP.im)}</div>
                                <div class="label">Final IM</div>
                            </div>
                            <div class="summary-stat">
                                <div class="value ${imChangeClass}">${formatCurrency(Math.abs(imChange))}</div>
                                <div class="label">${imChange <= 0 ? 'Reduction' : 'Increase'}</div>
                            </div>
                        </div>
                        <div class="trade-type-breakdown">
                            ${Object.entries(typeCount).map(([type, count]) =>
                                `<span class="trade-type-badge">${type}: ${count}</span>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';

            // Note: Overall summary is now at the top of the page (in the summary-section)

            portfoliosContainer.innerHTML = html;
        }

        // Update chart
        function updateChart(data) {
            const steps = data.optimization.steps;
            const svg = document.getElementById('imChart');
            const chartPath = document.getElementById('chartPath');
            const chartArea = document.getElementById('chartArea');

            if (steps.length === 0) return;

            const maxIM = Math.max(...steps.map(s => s.total_im));
            const minIM = Math.min(...steps.map(s => s.total_im));
            const range = maxIM - minIM || 1;

            const width = 800;
            const height = 150;
            const padding = 10;

            let pathD = '';
            let areaD = `M ${padding} ${height - padding}`;

            steps.forEach((step, i) => {
                const x = padding + (i / (steps.length - 1 || 1)) * (width - 2 * padding);
                const y = height - padding - ((step.total_im - minIM) / range) * (height - 2 * padding);

                if (i === 0) {
                    pathD = `M ${x} ${y}`;
                    areaD += ` L ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                    areaD += ` L ${x} ${y}`;
                }
            });

            areaD += ` L ${width - padding} ${height - padding} Z`;

            chartPath.setAttribute('d', pathD);
            chartArea.setAttribute('d', areaD);
        }

        // Update movement log
        const MAX_VISIBLE_MOVEMENTS = 50;
        let showAllMovements = false;

        function updateMovementLog(movements) {
            if (movements.length === 0) {
                movementLog.innerHTML = '<p style="color: #666;">No trade movements in optimization</p>';
                return;
            }

            const displayCount = showAllMovements ? movements.length : Math.min(movements.length, MAX_VISIBLE_MOVEMENTS);
            const hiddenCount = movements.length - displayCount;

            let html = '';
            for (let i = 0; i < displayCount; i++) {
                const m = movements[i];
                html += `
                    <div class="movement-entry">
                        <span class="trade-name">${m.trade_id}</span>
                        <span class="portfolio-badge from">P${m.from_portfolio + 1}</span>
                        <span class="arrow">→</span>
                        <span class="portfolio-badge to">P${m.to_portfolio + 1}</span>
                        <span style="color: #888; margin-left: auto;">IM: ${formatCurrency(m.standalone_im)}</span>
                    </div>
                `;
            }

            if (hiddenCount > 0 && !showAllMovements) {
                html += `
                    <div class="movement-entry" style="justify-content: center; cursor: pointer; background: rgba(79, 195, 247, 0.1);"
                         onclick="showAllMovements = true; updateMovementLog(demoData.optimization.movements);">
                        <span style="color: #4fc3f7;">Show ${hiddenCount} more movements...</span>
                    </div>
                `;
            } else if (movements.length > MAX_VISIBLE_MOVEMENTS && showAllMovements) {
                html += `
                    <div class="movement-entry" style="justify-content: center; cursor: pointer; background: rgba(79, 195, 247, 0.1);"
                         onclick="showAllMovements = false; updateMovementLog(demoData.optimization.movements);">
                        <span style="color: #4fc3f7;">Show less</span>
                    </div>
                `;
            }

            movementLog.innerHTML = html;
        }

        // Event listeners
        // Get selected trade types from checkboxes
        function getSelectedTradeTypes() {
            const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]:checked');
            const types = Array.from(checkboxes).map(cb => cb.value);
            return types.length > 0 ? types.join(',') : 'ir_swap';
        }

        document.getElementById('runOptimization').addEventListener('click', async () => {
            const numTrades = parseInt(document.getElementById('numTrades').value);
            const numPortfolios = parseInt(document.getElementById('numPortfolios').value);
            const tradeTypes = getSelectedTradeTypes();
            const avgMaturity = parseFloat(document.getElementById('avgMaturity').value) || 5;
            const maturitySpread = parseFloat(document.getElementById('maturitySpread').value) || 1;

            // Show loading with more info for large datasets
            const isLarge = numTrades > LARGE_DATASET_THRESHOLD;
            portfoliosContainer.innerHTML = `
                <div class="optimization-running">
                    <div class="big-spinner"></div>
                    <h3>Running Optimization</h3>
                    <p>${numTrades} trades across ${numPortfolios} portfolios</p>
                    <p style="color: #aaa;">Maturity: ${avgMaturity}Y ± ${maturitySpread}Y</p>
                    ${isLarge ? '<p style="color: #ffa726; margin-top: 10px;">Large dataset - this may take longer...</p>' : ''}
                    <div class="live-stats">
                        <div class="live-stat">
                            <div class="value" id="liveIteration">-</div>
                            <div class="label">Iteration</div>
                        </div>
                        <div class="live-stat">
                            <div class="value" id="liveIM">-</div>
                            <div class="label">Current IM</div>
                        </div>
                    </div>
                </div>
            `;

            // Try to fetch from backend with timeout, fall back to sample data
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout

            try {
                const response = await fetch(`/run_optimization?trades=${numTrades}&portfolios=${numPortfolios}&types=${tradeTypes}&avgMaturity=${avgMaturity}&maturitySpread=${maturitySpread}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (response.ok) {
                    const data = await response.json();
                    initializeVisualization(data, true); // true = from real backend
                } else {
                    throw new Error('Backend not available');
                }
            } catch (e) {
                clearTimeout(timeoutId);
                // Generate sample data instead - use setTimeout to allow UI to render first
                console.log('Using sample data (backend not available):', e.message);
                // Use setTimeout to allow loading state to render before blocking computation
                setTimeout(() => {
                    try {
                        const startTime = performance.now();
                        const data = generateSampleData(numTrades, numPortfolios);
                        const elapsed = (performance.now() - startTime) / 1000;
                        console.log(`Generated sample data in ${elapsed.toFixed(2)}s`);
                        showAllMovements = false; // Reset movement log state
                        initializeVisualization(data, false, elapsed);
                    } catch (genError) {
                        console.error('Error generating sample data:', genError);
                        portfoliosContainer.innerHTML = `
                            <div class="optimization-running" style="background: rgba(239, 68, 68, 0.1);">
                                <h3 style="color: #ef4444;">Error generating data</h3>
                                <p>${genError.message}</p>
                                <p style="color: #888; margin-top: 10px;">Try reducing the number of trades.</p>
                            </div>
                        `;
                    }
                }, 100);
            }
        });

        document.getElementById('loadSample').addEventListener('click', () => {
            const numTrades = parseInt(document.getElementById('numTrades').value);
            const numPortfolios = parseInt(document.getElementById('numPortfolios').value);

            // Show loading state
            portfoliosContainer.innerHTML = `
                <div class="optimization-running">
                    <div class="big-spinner"></div>
                    <h3>Generating Sample Data</h3>
                    <p>${numTrades} trades across ${numPortfolios} portfolios</p>
                </div>
            `;

            setTimeout(() => {
                const startTime = performance.now();
                const data = generateSampleData(numTrades, numPortfolios);
                const elapsed = (performance.now() - startTime) / 1000;
                showAllMovements = false;
                initializeVisualization(data, false, elapsed);
            }, 50);
        });

        // Toggle details sections
        function toggleDetails(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '−';
            } else {
                content.style.display = 'none';
                icon.textContent = '+';
            }
        }

        // Initialize SIMM parameters display
        function initializeSIMMParams() {
            // IR Weights table - show currency-specific weights
            let irHtml = '<tr><th>Tenor</th><th>Regular</th><th>Low Vol</th><th>High Vol</th></tr>';
            SIMM_PARAMS.irTenors.forEach((tenor, i) => {
                const regW = SIMM_PARAMS.irWeights.regular[i];
                const lowW = SIMM_PARAMS.irWeights.low[i];
                const highW = SIMM_PARAMS.irWeights.high[i];
                irHtml += `<tr><td>${tenor}</td><td class="num">${regW}</td><td class="num" style="color:#4fc3f7">${lowW}</td><td class="num" style="color:#f44336">${highW}</td></tr>`;
            });
            irHtml += `<tr style="font-size:0.75em;color:#888"><td colspan="4">Low: ${SIMM_PARAMS.lowVolCurrencies.join(', ')} | High: ${SIMM_PARAMS.highVolCurrencies.join(', ')}</td></tr>`;
            document.getElementById('irWeightsTable').innerHTML = irHtml;

            // Other weights table
            let otherHtml = '';
            Object.entries(SIMM_PARAMS.otherWeights).forEach(([type, weight]) => {
                const intraCorr = SIMM_PARAMS.intraCorrelations[type.replace(' Vol', '')] || '-';
                otherHtml += `<tr><td>${type}</td><td class="num">${weight}</td></tr>`;
            });
            document.getElementById('otherWeightsTable').innerHTML = otherHtml;

            // Cross-risk-class correlation matrix (psi)
            let corrHtml = '<thead><tr><th></th>';
            SIMM_PARAMS.riskClasses.forEach(rc => {
                corrHtml += `<th>${rc.substring(0, 6)}</th>`;
            });
            corrHtml += '</tr></thead><tbody>';
            SIMM_PARAMS.riskClasses.forEach((rc, i) => {
                corrHtml += `<tr><th>${rc}</th>`;
                SIMM_PARAMS.psiMatrix[i].forEach((val, j) => {
                    const cls = i === j ? 'diag' : '';
                    corrHtml += `<td class="${cls}">${val.toFixed(2)}</td>`;
                });
                corrHtml += '</tr>';
            });
            corrHtml += '</tbody>';
            document.getElementById('correlationMatrix').innerHTML = corrHtml;

            // Show sample IR tenor correlations in console for verification
            console.log('ISDA SIMM v2.6 - Sample IR Correlations:');
            console.log('  ρ(2W, 30Y) =', getIRCorrelation(0, 11).toFixed(3), '(short vs long)');
            console.log('  ρ(5Y, 10Y) =', getIRCorrelation(7, 8).toFixed(3), '(adjacent tenors)');
            console.log('  ρ(1Y, 2Y)  =', getIRCorrelation(4, 5).toFixed(3));
        }

        // Populate CRIF and calculation details
        const MAX_CRIF_TRADES_IN_DROPDOWN = 100;
        const MAX_CRIF_TABLE_ROWS = 500;

        function populateCRIFDetails(data) {
            if (!data.crif_data) {
                // Generate synthetic CRIF data for sample (limit for large datasets)
                data.crif_data = generateSyntheticCRIF(data);
            }

            // Populate trade filter dropdown (limit options for large datasets)
            const tradeFilter = document.getElementById('crifTradeFilter');
            const tradesToShow = data.trades.slice(0, MAX_CRIF_TRADES_IN_DROPDOWN);
            const hiddenTradeCount = data.trades.length - tradesToShow.length;

            tradeFilter.innerHTML = '<option value="all">All Trades</option>';
            if (hiddenTradeCount > 0) {
                tradeFilter.innerHTML += `<option disabled>── First ${MAX_CRIF_TRADES_IN_DROPDOWN} of ${data.trades.length} ──</option>`;
            }
            tradesToShow.forEach(t => {
                tradeFilter.innerHTML += `<option value="${t.id}">${t.id}</option>`;
            });

            // Populate risk type filter
            const riskTypes = [...new Set(data.crif_data.map(r => r.riskType))];
            const riskFilter = document.getElementById('crifRiskFilter');
            riskFilter.innerHTML = '<option value="all">All Risk Types</option>';
            riskTypes.forEach(rt => {
                riskFilter.innerHTML += `<option value="${rt}">${rt}</option>`;
            });

            // Populate CRIF table
            updateCRIFTable(data.crif_data);

            // Populate risk breakdown by portfolio
            updateRiskBreakdown(data);

            // Populate calculation details
            updateCalcDetails(data);
        }

        // Generate synthetic CRIF data for sample data
        const MAX_CRIF_TRADES = 500; // Limit CRIF generation for very large datasets

        function generateSyntheticCRIF(data) {
            const crif = [];
            const riskTypes = ['Risk_IRCurve', 'Risk_FX', 'Risk_Equity', 'Risk_Inflation'];
            const currencies = ['USD', 'EUR', 'GBP'];

            // Limit trades for CRIF generation in large datasets
            const tradesToProcess = data.trades.length > MAX_CRIF_TRADES
                ? data.trades.slice(0, MAX_CRIF_TRADES)
                : data.trades;

            tradesToProcess.forEach(trade => {
                // Generate IR sensitivities
                const numIRSens = Math.floor(Math.random() * 6) + 3;
                for (let i = 0; i < numIRSens; i++) {
                    const tenorIdx = Math.floor(Math.random() * 12);
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.1;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_IRCurve',
                        qualifier: trade.currency,
                        bucket: tenorIdx + 1,
                        label1: SIMM_PARAMS.irTenors[tenorIdx],
                        tenorIdx: tenorIdx,  // Store for correlation lookup
                        amount: amount,
                        riskWeight: getIRRiskWeight(trade.currency, tenorIdx),  // Currency-specific
                        riskClass: 'Rates'
                    });
                }

                // Add FX sensitivity for FX trades
                if (trade.type.includes('FX') || trade.type.includes('XCCY')) {
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.2;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_FX',
                        qualifier: trade.currency + 'USD',
                        bucket: '',
                        label1: '',
                        amount: amount,
                        riskWeight: SIMM_PARAMS.otherWeights['FX'],
                        riskClass: 'FX'
                    });
                }

                // Add Equity sensitivity for equity trades
                if (trade.type.includes('Equity')) {
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.15;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_Equity',
                        qualifier: 'Equity_' + Math.floor(Math.random() * 10),
                        bucket: Math.floor(Math.random() * 11) + 1,
                        label1: '',
                        amount: amount,
                        riskWeight: SIMM_PARAMS.otherWeights['Equity'],
                        riskClass: 'Equity'
                    });
                }
            });

            return crif;
        }

        // Update CRIF table with filtering and pagination
        function updateCRIFTable(crifData) {
            const tradeFilter = document.getElementById('crifTradeFilter').value;
            const riskFilter = document.getElementById('crifRiskFilter').value;

            let filtered = crifData;
            if (tradeFilter !== 'all') {
                filtered = filtered.filter(r => r.tradeId === tradeFilter);
            }
            if (riskFilter !== 'all') {
                filtered = filtered.filter(r => r.riskType === riskFilter);
            }

            const totalCount = filtered.length;
            const displayCount = Math.min(totalCount, MAX_CRIF_TABLE_ROWS);
            const hiddenCount = totalCount - displayCount;

            const tbody = document.getElementById('crifTableBody');
            let html = '';

            for (let i = 0; i < displayCount; i++) {
                const row = filtered[i];
                const amtClass = row.amount >= 0 ? 'positive' : 'negative';
                const weighted = row.amount * row.riskWeight;
                const wtdClass = weighted >= 0 ? 'positive' : 'negative';
                html += `
                    <tr>
                        <td>${row.tradeId}</td>
                        <td>${row.riskType}</td>
                        <td>${row.qualifier}</td>
                        <td>${row.bucket}</td>
                        <td>${row.label1}</td>
                        <td class="num ${amtClass}">${formatNumber(row.amount)}</td>
                        <td class="num">${row.riskWeight}</td>
                        <td class="num ${wtdClass}">${formatNumber(weighted)}</td>
                    </tr>
                `;
            }

            if (hiddenCount > 0) {
                html += `
                    <tr>
                        <td colspan="8" style="text-align:center; color:#4fc3f7; background: rgba(79, 195, 247, 0.1);">
                            Showing ${displayCount} of ${totalCount} rows. Use filters to narrow down.
                        </td>
                    </tr>
                `;
            }

            tbody.innerHTML = html || '<tr><td colspan="8" style="text-align:center;color:#666;">No data</td></tr>';
        }

        // Filter CRIF table
        function filterCRIF() {
            if (demoData && demoData.crif_data) {
                updateCRIFTable(demoData.crif_data);
            }
        }

        // Update risk breakdown by portfolio
        function updateRiskBreakdown(data) {
            const container = document.getElementById('riskTables');
            let html = '';

            // Pre-build trade ID to portfolio mapping for O(1) lookup
            const tradeToPortfolio = {};
            data.trades.forEach((t, i) => {
                tradeToPortfolio[t.id] = data.final_state.assignments[i];
            });

            // Pre-build CRIF by portfolio in O(C) instead of O(P * C)
            const crifByPortfolio = {};
            for (let p = 0; p < data.config.num_portfolios; p++) {
                crifByPortfolio[p] = [];
            }
            data.crif_data.forEach(row => {
                const p = tradeToPortfolio[row.tradeId];
                if (p !== undefined) {
                    crifByPortfolio[p].push(row);
                }
            });

            // Pre-count trades per portfolio
            const tradesPerPortfolio = new Array(data.config.num_portfolios).fill(0);
            data.final_state.assignments.forEach(p => tradesPerPortfolio[p]++);

            for (let p = 0; p < data.config.num_portfolios; p++) {
                const pCRIF = crifByPortfolio[p];
                const numTrades = tradesPerPortfolio[p];

                // Aggregate by risk class with weighted sensitivities
                const byRiskClass = {};
                SIMM_PARAMS.riskClasses.forEach(rc => byRiskClass[rc] = {
                    sensSum: 0,
                    wtdSensList: [],  // For correlation calculation
                    tenorIdxList: [], // For IR correlation lookup
                    count: 0
                });

                pCRIF.forEach(row => {
                    const rc = row.riskClass || 'Rates';
                    byRiskClass[rc].sensSum += row.amount;
                    byRiskClass[rc].wtdSensList.push(row.amount * row.riskWeight);
                    byRiskClass[rc].tenorIdxList.push(row.tenorIdx || 0);
                    byRiskClass[rc].count++;
                });

                // Calculate K values with ISDA correlations
                let totalK = 0;
                const kValues = {};
                SIMM_PARAMS.riskClasses.forEach(rc => {
                    const wsList = byRiskClass[rc].wtdSensList;
                    const tenorList = byRiskClass[rc].tenorIdxList;
                    const n = wsList.length;

                    if (n === 0) {
                        kValues[rc] = 0;
                        return;
                    }

                    // K² = Σ_i Σ_j ρ_ij × WS_i × WS_j
                    let kSquared = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            let rho;
                            if (rc === 'Rates') {
                                // IR: use tenor correlation matrix
                                rho = getIRCorrelation(tenorList[i], tenorList[j]);
                            } else {
                                // Other risk classes: intra-bucket correlation
                                rho = (i === j) ? 1.0 : (SIMM_PARAMS.intraCorrelations[rc] || 0.5);
                            }
                            kSquared += rho * wsList[i] * wsList[j];
                        }
                    }
                    kValues[rc] = Math.sqrt(Math.max(0, kSquared));
                    totalK += kValues[rc];
                });

                // Portfolio IM from data
                const pIM = data.final_state.portfolio_ims.find(x => x.portfolio === p)?.im || 0;

                html += `
                    <div class="risk-table-card">
                        <h5>Portfolio ${p + 1} (${numTrades} trades)</h5>
                        <table>
                            <thead>
                                <tr><th>Risk Class</th><th>Net Sens</th><th>K Value</th></tr>
                            </thead>
                            <tbody>
                `;

                SIMM_PARAMS.riskClasses.forEach(rc => {
                    if (byRiskClass[rc].count > 0 || kValues[rc] > 0) {
                        html += `
                            <tr>
                                <td>${rc}</td>
                                <td class="value">${formatNumber(byRiskClass[rc].sensSum)}</td>
                                <td class="value">${formatCurrency(kValues[rc])}</td>
                            </tr>
                        `;
                    }
                });

                html += `
                            <tr class="total-row">
                                <td>Total IM</td>
                                <td></td>
                                <td class="value">${formatCurrency(pIM)}</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Update calculation details
        function updateCalcDetails(data) {
            const container = document.getElementById('calcTables');
            let html = '';

            // Show before/after comparison
            html += `
                <div class="risk-table-card">
                    <h5>Initial Allocation</h5>
                    <table>
                        <thead><tr><th>Portfolio</th><th>Trades</th><th>IM</th></tr></thead>
                        <tbody>
            `;
            data.initial_state.portfolio_ims.forEach(p => {
                html += `<tr><td>Portfolio ${p.portfolio + 1}</td><td>${p.trades}</td><td class="value">${formatCurrency(p.im)}</td></tr>`;
            });
            html += `
                        <tr class="total-row"><td>Total</td><td>${data.config.num_trades}</td><td class="value">${formatCurrency(data.initial_state.total_im)}</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            html += `
                <div class="risk-table-card">
                    <h5>Final Allocation</h5>
                    <table>
                        <thead><tr><th>Portfolio</th><th>Trades</th><th>IM</th></tr></thead>
                        <tbody>
            `;
            data.final_state.portfolio_ims.forEach(p => {
                html += `<tr><td>Portfolio ${p.portfolio + 1}</td><td>${p.trades}</td><td class="value">${formatCurrency(p.im)}</td></tr>`;
            });
            html += `
                        <tr class="total-row"><td>Total</td><td>${data.config.num_trades}</td><td class="value">${formatCurrency(data.final_state.total_im)}</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            // Savings summary
            const savings = data.initial_state.total_im - data.final_state.total_im;
            html += `
                <div class="risk-table-card" style="background: rgba(102, 187, 106, 0.1);">
                    <h5 style="color: #66bb6a;">Optimization Savings</h5>
                    <table>
                        <tbody>
                            <tr><td>Initial IM</td><td class="value">${formatCurrency(data.initial_state.total_im)}</td></tr>
                            <tr><td>Final IM</td><td class="value">${formatCurrency(data.final_state.total_im)}</td></tr>
                            <tr class="total-row" style="color: #66bb6a;"><td>Savings</td><td class="value">${formatCurrency(savings)} (${formatPercent(data.optimization.im_reduction_pct)})</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = html;
        }

        // Format number with sign
        function formatNumber(value) {
            if (Math.abs(value) >= 1e9) {
                return (value >= 0 ? '+' : '') + (value / 1e9).toFixed(2) + 'B';
            } else if (Math.abs(value) >= 1e6) {
                return (value >= 0 ? '+' : '') + (value / 1e6).toFixed(2) + 'M';
            } else if (Math.abs(value) >= 1e3) {
                return (value >= 0 ? '+' : '') + (value / 1e3).toFixed(2) + 'K';
            }
            return (value >= 0 ? '+' : '') + value.toFixed(2);
        }

        // Initialize params on load
        initializeSIMMParams();

        // Load sample data on page load for demo
        window.addEventListener('load', () => {
            // Don't auto-load, let user click a button
        });
    </script>
</body>
</html>
