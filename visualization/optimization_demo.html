<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIMM Trade Allocation Optimizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        /* Control Panel */
        .control-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.8em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group input, .control-group select {
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 6px;
            background: #2a2a4a;
            color: #fff;
            font-size: 1em;
            min-width: 120px;
        }

        .trade-types-group {
            min-width: 200px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: #2a2a4a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .checkbox-label:hover {
            border-color: #4fc3f7;
        }

        .checkbox-label input[type="checkbox"] {
            min-width: auto;
            width: 14px;
            height: 14px;
            margin: 0;
            padding: 0;
            accent-color: #4fc3f7;
        }

        .checkbox-label input[type="checkbox"]:checked + span {
            color: #4fc3f7;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.4);
        }

        .btn-secondary {
            background: #444;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Optimization Summary Section */
        .summary-section {
            background: linear-gradient(135deg, rgba(102, 187, 106, 0.15) 0%, rgba(79, 195, 247, 0.1) 100%);
            border: 1px solid rgba(102, 187, 106, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .summary-section h2 {
            color: #66bb6a;
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }

        /* Stats Panel */
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 0;
        }

        .stat-card {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-card.highlight {
            background: rgba(102, 187, 106, 0.2);
            border: 1px solid rgba(102, 187, 106, 0.4);
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #4fc3f7;
            margin-bottom: 5px;
        }

        .stat-value.positive {
            color: #66bb6a;
        }

        .stat-value.negative {
            color: #ef5350;
        }

        .stat-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Methodology Section */
        .methodology-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .methodology-section h3 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .methodology-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .methodology-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #4fc3f7;
        }

        .methodology-card h4 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .methodology-card p {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .methodology-card ul {
            color: #aaa;
            font-size: 0.85em;
            line-height: 1.6;
            margin-left: 20px;
        }

        .methodology-card code {
            background: rgba(79, 195, 247, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
            color: #4fc3f7;
        }

        .greeks-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            margin-top: 10px;
        }

        .greeks-table th, .greeks-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .greeks-table th {
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.8em;
        }

        .greeks-table td {
            color: #ccc;
        }

        .greeks-table .risk-type {
            color: #4fc3f7;
            font-family: monospace;
        }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #29b6f6);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .optimization-note {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(255, 167, 38, 0.1);
            border-left: 3px solid #ffa726;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ffa726;
        }

        /* Portfolio Containers */
        .portfolios-container {
            display: block;
            width: 100%;
            margin-bottom: 20px;
            min-height: 200px;
        }

        .portfolio {
            flex: 1;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 15px;
            min-height: 350px;
            position: relative;
            border: 2px solid transparent;
            transition: border-color 0.3s ease;
        }

        .portfolio.highlight {
            border-color: #4fc3f7;
        }

        .portfolio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .portfolio-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #4fc3f7;
        }

        .portfolio-im {
            font-size: 0.9em;
            color: #aaa;
        }

        .portfolio-im .value {
            color: #fff;
            font-weight: 600;
        }

        .trades-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 200px;
            align-content: flex-start;
        }

        /* Trade Cards */
        .trade {
            background: linear-gradient(135deg, #2d2d5a, #252550);
            border-radius: 8px;
            padding: 10px;
            width: calc(50% - 5px);
            min-width: 100px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border: 1px solid #444;
        }

        .trade:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-color: #4fc3f7;
        }

        .trade.moving {
            position: fixed;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(79, 195, 247, 0.5);
            border-color: #4fc3f7;
        }

        .trade.highlight-move {
            animation: pulse 0.5s ease-in-out;
            border-color: #66bb6a;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .trade-id {
            font-size: 0.75em;
            color: #4fc3f7;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .trade-type {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
        }

        .trade-im {
            font-size: 0.8em;
            color: #aaa;
        }

        .trade-im .value {
            color: #66bb6a;
            font-weight: 600;
        }

        /* Trade type colors */
        .trade.type-IRSwap { border-left: 3px solid #4fc3f7; }
        .trade.type-EquityOption { border-left: 3px solid #ab47bc; }
        .trade.type-FXOption { border-left: 3px solid #ffa726; }
        .trade.type-InflationSwap { border-left: 3px solid #66bb6a; }
        .trade.type-XCCYSwap { border-left: 3px solid #ef5350; }

        /* Animation Controls */
        /* Before/After Portfolio Comparison */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .comparison-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .comparison-section h3 {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .comparison-section.before h3 {
            color: #ffa726;
        }

        .comparison-section.after h3 {
            color: #66bb6a;
        }

        .portfolio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .portfolio-card {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid;
        }

        .portfolio-card h4 {
            margin-bottom: 10px;
            font-size: 1em;
        }

        .portfolio-card .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .portfolio-card .stat-row .label {
            color: #888;
        }

        .portfolio-card .stat-row .value {
            font-weight: 600;
        }

        .portfolio-card .change {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            text-align: center;
            font-size: 0.85em;
        }

        .portfolio-card .change.positive {
            color: #66bb6a;
        }

        .portfolio-card .change.negative {
            color: #ef5350;
        }

        @media (max-width: 900px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
        }

        /* IM Chart */
        .chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 1em;
            color: #aaa;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .im-chart {
            height: 150px;
            position: relative;
            border-left: 1px solid #444;
            border-bottom: 1px solid #444;
        }

        .chart-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .chart-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #4fc3f7;
            border-radius: 50%;
            transform: translate(-50%, 50%);
            transition: all 0.3s ease;
        }

        .chart-path {
            fill: none;
            stroke: #4fc3f7;
            stroke-width: 2;
        }

        .chart-area {
            fill: rgba(79, 195, 247, 0.1);
        }

        /* Movement Log */
        .movement-log {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .movement-log h3 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .movement-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .movement-entry .arrow {
            color: #4fc3f7;
            font-weight: bold;
        }

        .movement-entry .trade-name {
            color: #fff;
            font-weight: 600;
        }

        .movement-entry .portfolio-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .portfolio-badge.from {
            background: rgba(239, 83, 80, 0.2);
            color: #ef5350;
        }

        .portfolio-badge.to {
            background: rgba(102, 187, 106, 0.2);
            color: #66bb6a;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .portfolios-container {
                flex-direction: column;
            }

            .trade {
                width: 100%;
            }
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #1a1a2e;
            border: 1px solid #4fc3f7;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.8em;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* Details Sections */
        .details-section {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .details-header:hover {
            background: rgba(255,255,255,0.05);
        }

        .details-header h3 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
        }

        .toggle-icon {
            color: #4fc3f7;
            font-size: 1.5em;
            font-weight: bold;
        }

        .details-content {
            padding: 0 20px 20px;
        }

        /* Risk Summary Tables */
        .risk-tables {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .risk-table-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
        }

        .risk-table-card h5 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .risk-table-card table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .risk-table-card th, .risk-table-card td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .risk-table-card th {
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.8em;
        }

        .risk-table-card td.value {
            text-align: right;
            font-family: monospace;
        }

        .risk-table-card .total-row {
            font-weight: bold;
            color: #4fc3f7;
            border-top: 2px solid #4fc3f7;
        }

        /* CRIF Table */
        .crif-section {
            margin-top: 20px;
        }

        .crif-section h4 {
            color: #aaa;
            margin-bottom: 15px;
        }

        .crif-filter {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .crif-filter label {
            color: #888;
            font-size: 0.85em;
        }

        .crif-filter select {
            padding: 6px 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #2a2a4a;
            color: #fff;
            font-size: 0.85em;
        }

        .crif-table-container {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
        }

        .crif-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }

        .crif-table th {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            padding: 10px 8px;
            text-align: left;
            border-bottom: 2px solid #4fc3f7;
        }

        .crif-table td {
            padding: 8px;
            border-bottom: 1px solid #333;
        }

        .crif-table tr:hover {
            background: rgba(79, 195, 247, 0.1);
        }

        .crif-table .num {
            text-align: right;
            font-family: monospace;
        }

        .crif-table .positive { color: #66bb6a; }
        .crif-table .negative { color: #ef5350; }

        /* Calculation Details */
        .calc-explanation {
            margin-bottom: 20px;
        }

        .calc-explanation h4 {
            color: #aaa;
            margin-bottom: 10px;
        }

        .formula-box {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            border-left: 3px solid #4fc3f7;
        }

        .formula-box p {
            margin: 8px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1em;
        }

        .formula-note {
            color: #888;
            font-size: 0.85em !important;
            font-style: italic;
        }

        .calc-tables {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
        }

        /* Parameters Grid */
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .params-section h4 {
            color: #aaa;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .params-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            overflow: hidden;
        }

        .params-table th, .params-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .params-table th {
            background: rgba(0,0,0,0.3);
            color: #888;
            font-weight: normal;
        }

        .params-table td.num {
            text-align: right;
            font-family: monospace;
            color: #4fc3f7;
        }

        .correlation-matrix {
            grid-column: span 2;
        }

        .correlation-matrix table {
            font-size: 0.8em;
        }

        .correlation-matrix td, .correlation-matrix th {
            text-align: center;
            padding: 6px;
            min-width: 60px;
        }

        .correlation-matrix .diag {
            background: rgba(79, 195, 247, 0.2);
            font-weight: bold;
        }

        .risk-summary h4, .crif-section h4 {
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Large dataset mode */
        .large-dataset-notice {
            background: rgba(255, 167, 38, 0.1);
            border: 1px solid #ffa726;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .large-dataset-notice .icon {
            font-size: 2em;
        }

        .large-dataset-notice .text {
            flex: 1;
        }

        .large-dataset-notice .text h4 {
            color: #ffa726;
            margin-bottom: 5px;
        }

        .large-dataset-notice .text p {
            color: #aaa;
            font-size: 0.9em;
            margin: 0;
        }

        /* Summary view for large datasets */
        .portfolio-summary {
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .portfolio-summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .portfolio-summary-header h4 {
            color: #4fc3f7;
            margin: 0;
        }

        .portfolio-summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .summary-stat {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .summary-stat .value {
            font-size: 1.3em;
            font-weight: bold;
            color: #4fc3f7;
        }

        .summary-stat .label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .trade-type-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .trade-type-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            background: rgba(79, 195, 247, 0.1);
            color: #4fc3f7;
        }

        /* Animation progress for large datasets */
        .optimization-running {
            text-align: center;
            padding: 40px;
        }

        .optimization-running .big-spinner {
            border: 4px solid #333;
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .optimization-running h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }

        .optimization-running p {
            color: #888;
        }

        .live-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .live-stat {
            text-align: center;
        }

        .live-stat .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        .live-stat .label {
            font-size: 0.8em;
            color: #888;
        }

        /* Chart marker for current iteration */
        #chartMarker {
            filter: drop-shadow(0 0 4px rgba(255, 167, 38, 0.8));
            transition: all 0.15s ease;
        }

        /* Highlight completed state */
        .portfolio-summary.completed {
            animation: pulse-green 0.5s ease;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 20px rgba(102, 187, 106, 0.5); }
        }

        /* Performance Banner */
        .performance-banner {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.1) 0%, rgba(102, 187, 106, 0.05) 100%);
            border: 1px solid rgba(79, 195, 247, 0.2);
            border-radius: 12px;
        }
        .perf-card { text-align: center; }
        .perf-value { font-size: 1.4em; font-weight: bold; color: #66bb6a; }
        .perf-label { font-size: 0.75em; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; }
        .perf-detail { font-size: 0.7em; color: #666; margin-top: 2px; }

        /* Intro Section */
        .intro-section {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 24px 28px;
            margin-bottom: 24px;
            line-height: 1.7;
        }
        .intro-section > p {
            color: #bbb;
            font-size: 0.92em;
            margin-bottom: 16px;
        }
        .intro-section > p strong {
            color: #e0e0e0;
        }
        .intro-section a {
            color: #4fc3f7;
            text-decoration: none;
        }
        .intro-section a:hover {
            text-decoration: underline;
        }
        .intro-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 14px;
            margin-bottom: 16px;
        }
        .intro-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 14px 16px;
            border-left: 3px solid #4fc3f7;
        }
        .intro-card h4 {
            color: #4fc3f7;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }
        .intro-card p {
            color: #999;
            font-size: 0.82em;
            line-height: 1.6;
            margin: 0;
        }
        .intro-note {
            color: #777 !important;
            font-size: 0.82em !important;
            font-style: italic;
            margin-bottom: 0 !important;
        }

        /* Config Selector */
        .config-selector {
            margin-bottom: 20px;
        }
        .config-selector-header {
            margin-bottom: 12px;
        }
        .config-selector-header h3 {
            color: #4fc3f7;
            margin: 0;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        .config-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .config-card {
            padding: 12px 20px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 180px;
        }
        .config-card:hover {
            border-color: rgba(79, 195, 247, 0.4);
            background: rgba(79, 195, 247, 0.06);
        }
        .config-card.active {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
            box-shadow: 0 0 12px rgba(79, 195, 247, 0.15);
        }
        .config-card-title {
            font-weight: 600;
            color: #e0e0e0;
            font-size: 0.95em;
            margin-bottom: 4px;
        }
        .config-card-detail {
            color: #888;
            font-size: 0.78em;
        }
        .config-card-detail span {
            margin-right: 10px;
        }
        .config-meta {
            display: none;
        }

        /* Benchmark commands */
        .command-block {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 0.85em;
            color: #ccc;
            white-space: pre-wrap;
            word-break: break-all;
            border-left: 3px solid #4fc3f7;
        }
        .command-block .comment { color: #666; }

        /* Main Tabs */
        .main-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        .main-tab {
            padding: 10px 20px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            color: #888;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            transition: all 0.2s;
            position: relative;
            bottom: -2px;
        }
        .main-tab:hover { background: rgba(255,255,255,0.05); color: #e0e0e0; }
        .main-tab.active { background: rgba(79,195,247,0.15); border-color: #4fc3f7; color: #4fc3f7; }
        .main-tab-content { display: none; }
        .main-tab-content.active { display: block; }

        /* New Trade / What-If tab tables */
        .tab-data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .tab-data-table th, .tab-data-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .tab-data-table th {
            color: #888;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 0.8em;
            background: rgba(0,0,0,0.3);
        }
        .tab-data-table td { color: #ccc; }
        .tab-data-table .highlight-row { background: rgba(79,195,247,0.08); }
        .tab-data-table .num { text-align: right; font-family: monospace; }

        .comparison-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .comparison-panel {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        .comparison-panel.recommended {
            border: 2px solid #66bb6a;
        }
        .im-value-large {
            font-size: 1.6em;
            font-weight: 700;
            margin: 10px 0;
        }
        .speedup-callout {
            background: rgba(102,187,106,0.08);
            border: 1px solid rgba(102,187,106,0.2);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 20px;
            text-align: center;
            color: #aaa;
        }
        .speedup-callout strong { color: #66bb6a; }
        .badge-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }
        .badge-tag.success { background: rgba(102,187,106,0.2); color: #66bb6a; }
        .badge-tag.primary { background: rgba(79,195,247,0.2); color: #4fc3f7; }
        .badge-tag.warning { background: rgba(255,167,38,0.2); color: #ffa726; }
        .badge-tag.danger { background: rgba(239,83,80,0.2); color: #ef5350; }
        .rationale-box {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #aaa;
            font-size: 0.9em;
            line-height: 1.5;
        }
        .scenario-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }
        .scenario-card h4 {
            color: #e0e0e0;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        .scenario-card p {
            color: #888;
            font-size: 0.85em;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SIMM Trade Allocation Optimizer</h1>
        <p class="subtitle" id="pageSubtitle">Minimize Initial Margin through optimal portfolio allocation</p>

        <!-- Intro Section -->
        <div class="intro-section">
            <p>
                This page shows <strong>real benchmark results</strong> from an ISDA SIMM (Standard Initial Margin Model) portfolio optimizer
                powered by <a href="https://matlogica.com/aadc" target="_blank">AADC</a> (AAD Compiler) &mdash; MatLogica's high-performance
                Adjoint Algorithmic Differentiation engine.
            </p>
            <div class="intro-grid">
                <div class="intro-card">
                    <h4>Pricers</h4>
                    <p>Interest rate swaps, equity options, FX options, inflation swaps, and cross-currency swaps priced analytically with full CRIF (Common Risk Interchange Format) sensitivity generation.</p>
                </div>
                <div class="intro-card">
                    <h4>AADC Adjoint Gradients</h4>
                    <p>AADC computes exact sensitivities and IM gradients via Adjoint Algorithmic Differentiation in a single backward pass &mdash; orders of magnitude faster than bump-and-revalue. The gradient of total IM with respect to every trade allocation is computed in one call.</p>
                </div>
                <div class="intro-card">
                    <h4>Optimizer</h4>
                    <p>Gradient-based reallocation of trades across portfolios to minimize total Initial Margin. Uses AAD gradients to iteratively move trades to the portfolio where they reduce IM most, exploiting netting and diversification benefits.</p>
                </div>
            </div>
            <p class="intro-note">
                Select a configuration below to view its benchmark results. All timings and IM values are from actual executions of the AADC-enabled SIMM engine &mdash; no synthetic or simulated data.
            </p>
        </div>

        <!-- Main Tab Navigation -->
        <div class="main-tabs">
            <button class="main-tab active" onclick="switchMainTab('optimizer', this)">Portfolio Optimization</button>
            <button class="main-tab" onclick="switchMainTab('newtrade', this)">New Trade</button>
            <button class="main-tab" onclick="switchMainTab('whatif', this)">What-If Analytics</button>
            <button class="main-tab" onclick="switchMainTab('scaling', this)">Scaling Benchmarks</button>
        </div>

        <!-- Tab 1: Portfolio Optimization (existing content) -->
        <div id="tab-optimizer" class="main-tab-content active">

        <!-- Config Selector (populated from real data) -->
        <div class="config-selector" id="configSelector" style="display:none">
            <div class="config-selector-header">
                <h3>Execution Data</h3>
            </div>
            <div class="config-cards" id="configCards"></div>
            <select id="configDropdown" onchange="onConfigSelected()" style="display:none"></select>
            <div class="config-meta" id="configMeta"></div>
        </div>

        <!-- Performance Banner (AADC timing) -->
        <div class="performance-banner" id="perfBanner" style="display:none">
            <div class="perf-card">
                <div class="perf-value" id="perfCrif">-</div>
                <div class="perf-label">CRIF (AADC)</div>
                <div class="perf-detail" id="perfCrifDetail"></div>
            </div>
            <div class="perf-card">
                <div class="perf-value" id="perfSimm">-</div>
                <div class="perf-label">SIMM Aggregation</div>
                <div class="perf-detail" id="perfSimmDetail"></div>
            </div>
            <div class="perf-card">
                <div class="perf-value" id="perfGrad">-</div>
                <div class="perf-label">IM Gradient (AAD)</div>
                <div class="perf-detail" id="perfGradDetail"></div>
            </div>
            <div class="perf-card">
                <div class="perf-value" id="perfTotal">-</div>
                <div class="perf-label">Total Time</div>
                <div class="perf-detail" id="perfTotalDetail"></div>
            </div>
        </div>

        <!-- Manual panel removed - static deployment uses execution log data only -->

        <!-- Performance Banner Explanation -->
        <div id="perfExplanation" style="display:none;background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;margin-bottom:20px;border-left:3px solid #4fc3f7;">
            <h4 style="color:#4fc3f7;margin-bottom:8px;font-size:0.9em;">What These Timings Mean</h4>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">CRIF (AADC):</strong> Generates all trade sensitivities (Greeks) via a single forward + adjoint pass per trade,
                instead of bump-and-revalue. Each trade's price is recorded as an AADC kernel, and all Delta/Vega sensitivities
                are extracted in one backward pass &mdash; typically 20&ndash;50x faster than finite differences.
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">SIMM Aggregation:</strong> Records the ISDA SIMM formula (risk weighting, intra-bucket correlations,
                inter-bucket aggregation, cross-risk-class aggregation) as an AADC kernel with K aggregated sensitivities as inputs.
                This kernel is compact (&sim;100 inputs regardless of trade count) and is reused for all gradient evaluations.
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">IM Gradient (AAD):</strong> Evaluates
                <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">&part;IM/&part;Sensitivity[k]</code>
                for every risk factor via the pre-recorded SIMM kernel's adjoint. This gradient tells the optimizer
                how much each trade contributes to portfolio IM (Euler contribution) and how moving a trade would affect each target portfolio.
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                <strong style="color:#e0e0e0;">Total Time:</strong> Sum of all three phases. The SIMM kernel is recorded once and then evaluated
                many times during optimization (once per gradient refresh), so the amortized cost per iteration is dominated by the fast
                gradient evaluation (&sim;1 ms per portfolio).
            </p>
        </div>

        <!-- Optimization Summary Section (at top) -->
        <div class="summary-section" id="summarySection">
            <h2>Optimization Summary</h2>
            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-value" id="initialIM">-</div>
                    <div class="stat-label">Initial Total IM</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="finalIM">-</div>
                    <div class="stat-label">Final Total IM</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value positive" id="reduction">-</div>
                    <div class="stat-label">IM Reduction</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value positive" id="totalSavings">-</div>
                    <div class="stat-label">Total Savings</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="tradesMoved">-</div>
                    <div class="stat-label">Trades Moved</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="iterations">-</div>
                    <div class="stat-label">Iterations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="execTime">-</div>
                    <div class="stat-label">Execution Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="maturityInfo">-</div>
                    <div class="stat-label" id="maturityLabel">Avg Maturity</div>
                </div>
            </div>
        </div>

        <!-- Optimization Algorithm Explanation -->
        <div id="algoExplanation" style="display:none;background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;margin-bottom:20px;border-left:3px solid #66bb6a;">
            <h4 style="color:#66bb6a;margin-bottom:8px;font-size:0.9em;">How the Optimizer Works</h4>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">1. Rank trades by Euler contribution:</strong> Each trade's contribution to its portfolio's IM is computed as
                <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">contribution[t] = &Sigma;<sub>k</sub> gradient[k] &times; sensitivity[t,k]</code>.
                Trades with the largest absolute contribution are candidates for reallocation &mdash; they consume the most margin.
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">2. Estimate marginal impact on each target portfolio:</strong> For each candidate trade, the optimizer estimates
                what IM would be if the trade were added to each other portfolio, using a gradient dot product:
                <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">impact[p] = &Sigma;<sub>k</sub> gradient<sub>p</sub>[k] &times; trade_sensitivity[k]</code>.
                The trade moves to the portfolio where its absolute marginal impact is lowest.
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                <strong style="color:#e0e0e0;">3. Refresh gradients after each move:</strong> After each trade move, the AADC kernel is re-evaluated
                for the affected portfolios to update the gradients. This prevents the "stale gradient" problem where subsequent
                move decisions would be based on outdated information. With batched v2 evaluation, refreshing all portfolios
                costs a single <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">aadc.evaluate()</code>
                call (&sim;1 ms for all portfolios simultaneously).
            </p>
            <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                <strong style="color:#e0e0e0;">Why it works:</strong> SIMM margin depends on signed net sensitivities:
                <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">K = &radic;(&Sigma; &rho;<sub>ij</sub> &times; WS<sub>i</sub> &times; WS<sub>j</sub>)</code>.
                When a pay-fixed and receive-fixed swap share the same portfolio, their sensitivities partially cancel,
                reducing |WS| and therefore K. The gradient tells the optimizer exactly which portfolio provides the best cancellation
                for each trade, achieving 10&ndash;30% IM reduction.
            </p>
        </div>

        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-header">
                <span>Optimization Progress</span>
                <span id="progressText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div id="optimizationNote" class="optimization-note" style="display: none;">
                Note: Real optimization uses continuous allocation fractions. IM may change before trades visually move.
            </div>
        </div>


        <!-- Before/After Portfolio Comparison Section -->
        <div class="details-section" style="padding: 20px;">
            <h3 id="portfolioSectionTitle" style="color: #aaa; font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 15px;">Portfolio Comparison: Before vs After</h3>
            <div class="portfolios-container" id="portfoliosContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Configure parameters and click "Run Optimization" or "Load Sample Data"</p>
                </div>
            </div>
        </div>

        <!-- IM Chart -->
        <div class="chart-container" id="chartSection">
            <div class="chart-title">Total IM Over Iterations</div>
            <svg class="im-chart" id="imChart" viewBox="0 0 800 150" preserveAspectRatio="none">
                <path class="chart-area" id="chartArea"></path>
                <path id="chartRawPath" fill="none" stroke="rgba(79,195,247,0.2)" stroke-width="1"></path>
                <path class="chart-path" id="chartPath"></path>
            </svg>
            <div id="chartLabels" style="display:flex;justify-content:space-between;font-size:0.75em;color:#666;margin-top:4px;">
                <span id="chartLabelStart"></span>
                <span id="chartLabelEnd"></span>
            </div>
            <div id="chartLegend" style="display:flex;gap:20px;justify-content:center;font-size:0.75em;color:#888;margin-top:8px;">
                <span><span style="display:inline-block;width:20px;height:2px;background:#4fc3f7;vertical-align:middle;margin-right:4px;"></span> Best IM found so far</span>
                <span><span style="display:inline-block;width:20px;height:2px;background:rgba(79,195,247,0.2);vertical-align:middle;margin-right:4px;"></span> Raw per-iteration IM</span>
            </div>
        </div>

        <!-- Movement Log -->
        <div class="movement-log" id="movementSection">
            <h3>Trade Movements</h3>
            <div id="movementLog">
                <p style="color: #666;">No movements yet</p>
            </div>
        </div>

        <!-- CRIF & Calculation Details -->
        <div class="details-section" id="crifSection">
            <div class="details-header" onclick="toggleDetails('crifDetails')">
                <h3>CRIF Sensitivities & Risk Breakdown</h3>
                <span class="toggle-icon" id="crifDetailsIcon">+</span>
            </div>
            <div class="details-content" id="crifDetails" style="display: none;">
                <!-- Risk Class Summary -->
                <div class="risk-summary">
                    <h4>Portfolio Risk Class Breakdown</h4>
                    <div class="risk-tables" id="riskTables"></div>
                </div>

                <!-- Trade CRIF Details -->
                <div class="crif-section">
                    <h4>Trade Sensitivities (CRIF Format)</h4>
                    <div class="crif-filter">
                        <label>Filter by Trade:</label>
                        <select id="crifTradeFilter" onchange="filterCRIF()">
                            <option value="all">All Trades</option>
                        </select>
                        <label style="margin-left: 15px;">Filter by Risk Type:</label>
                        <select id="crifRiskFilter" onchange="filterCRIF()">
                            <option value="all">All Risk Types</option>
                        </select>
                    </div>
                    <div class="crif-table-container">
                        <table class="crif-table" id="crifTable">
                            <thead>
                                <tr>
                                    <th>TradeID</th>
                                    <th>RiskType</th>
                                    <th>Qualifier</th>
                                    <th>Bucket</th>
                                    <th>Label1</th>
                                    <th>Amount</th>
                                    <th>RiskWeight</th>
                                    <th>Weighted</th>
                                </tr>
                            </thead>
                            <tbody id="crifTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- IM Calculation Details -->
        <div class="details-section" id="calcSection">
            <div class="details-header" onclick="toggleDetails('calcDetails')">
                <h3>IM Calculation Breakdown</h3>
                <span class="toggle-icon" id="calcDetailsIcon">+</span>
            </div>
            <div class="details-content" id="calcDetails" style="display: none;">
                <div class="calc-explanation">
                    <h4>ISDA SIMM v2.6 Formula (with intra-bucket correlations)</h4>
                    <div class="formula-box">
                        <p><strong>Per Risk Class:</strong> K<sub>r</sub> = (<sub>i,j</sub> <span style="color:#4fc3f7"><sub>ij</sub></span>  WS<sub>i</sub>  WS<sub>j</sub>)</p>
                        <p><strong>Total IM:</strong> IM = (<sub>r,s</sub> <sub>rs</sub>  K<sub>r</sub>  K<sub>s</sub>)</p>
                        <p class="formula-note">where WS<sub>i</sub> = w<sub>i</sub>  s<sub>i</sub> (weighted sensitivity), <span style="color:#4fc3f7"><sub>ij</sub></span> = intra-bucket correlation, <sub>rs</sub> = cross-risk-class correlation</p>
                        <p class="formula-note" style="margin-top:8px;font-size:0.85em;color:#888;">
                            <strong>Correlations:</strong> IR uses 1212 tenor matrix (e.g., (5Y,10Y)=0.95). Same-sign positions increase K; opposite-sign positions offset.
                            <br><strong>Currency weights:</strong> USD/EUR use regular weights; JPY uses low-vol weights (~40% lower); BRL uses high-vol weights (~50% higher).
                        </p>
                    </div>
                </div>
                <div class="calc-tables" id="calcTables"></div>
            </div>
        </div>

        <!-- Correlation Matrix -->
        <div class="details-section">
            <div class="details-header" onclick="toggleDetails('corrDetails')">
                <h3>SIMM Parameters (Risk Weights & Correlations)</h3>
                <span class="toggle-icon" id="corrDetailsIcon">+</span>
            </div>
            <div class="details-content" id="corrDetails" style="display: none;">
                <div class="params-grid">
                    <div class="params-section">
                        <h4>IR Risk Weights by Tenor</h4>
                        <table class="params-table">
                            <thead><tr><th>Tenor</th><th>Weight</th></tr></thead>
                            <tbody id="irWeightsTable"></tbody>
                        </table>
                    </div>
                    <div class="params-section">
                        <h4>Other Risk Weights</h4>
                        <table class="params-table">
                            <thead><tr><th>Risk Type</th><th>Weight</th></tr></thead>
                            <tbody id="otherWeightsTable"></tbody>
                        </table>
                    </div>
                    <div class="params-section correlation-matrix">
                        <h4>Cross-Risk-Class Correlations ()</h4>
                        <table class="params-table" id="correlationMatrix"></table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Generate New Benchmarks -->
        <div class="details-section">
            <div class="details-header" onclick="toggleDetails('benchmarkCommands')">
                <h3>Generate New Benchmarks</h3>
                <span class="toggle-icon" id="benchmarkCommandsIcon">+</span>
            </div>
            <div class="details-content" id="benchmarkCommands" style="display: none;">
                <p style="color:#aaa;margin-bottom:15px;">Run these commands to generate data for new configurations:</p>
                <div class="command-block"><span class="comment"># Activate virtual environment</span>
source venv/bin/activate

<span class="comment"># Small portfolio (quick test)</span>
python -m model.simm_portfolio_aadc --trades 10 --portfolios 3 --trade-types ir_swap --optimize

<span class="comment"># Mixed instruments</span>
python -m model.simm_portfolio_aadc --trades 20 --portfolios 5 --trade-types ir_swap,equity_option,fx_option --optimize

<span class="comment"># Large portfolio</span>
python -m model.simm_portfolio_aadc --trades 100 --portfolios 10 --trade-types ir_swap,equity_option,fx_option,inflation_swap,xccy_swap --optimize

<span class="comment"># Generate visualization data for current config</span>
python scripts/export_animation_data.py --trades 15 --portfolios 3 --trade-types ir_swap

<span class="comment"># Then reload this page</span></div>
            </div>
        </div>

        <!-- Methodology Section -->
        <div class="methodology-section">
            <h3>How It Works: ISDA SIMM Optimization</h3>
            <div class="methodology-grid">
                <div class="methodology-card">
                    <h4>ISDA SIMM v2.6</h4>
                    <p>The Standard Initial Margin Model (SIMM) is a risk-based methodology for calculating initial margin requirements for non-cleared derivatives.</p>
                    <p>The margin captures Delta, Vega, and Curvature risk across six risk classes: Rates, CreditQ, CreditNonQ, Equity, Commodity, and FX.</p>
                </div>
                <div class="methodology-card">
                    <h4>Why Allocation Matters</h4>
                    <p>Random allocation splits natural hedges across portfolios, eliminating netting benefits:</p>
                    <ul>
                        <li>Pay-fixed swap in Portfolio 1</li>
                        <li>Receive-fixed swap in Portfolio 2</li>
                        <li>No netting  Higher total IM</li>
                    </ul>
                    <p style="margin-top: 10px;">Optimal allocation groups offsetting positions in the same portfolio, achieving <strong>10-30% IM reduction</strong>.</p>
                </div>
                <div class="methodology-card">
                    <h4>Netting Model</h4>
                    <p>The SIMM formula captures netting through signed sensitivities:</p>
                    <p style="font-family: monospace; color: #4fc3f7; margin: 10px 0;">
                        IM    | sensitivities| +   ( sens)
                    </p>
                    <p>When opposite sensitivities are grouped:</p>
                    <ul>
                        <li>|netted|  0 (cancellation)</li>
                        <li>Portfolio IM decreases significantly</li>
                    </ul>
                </div>
                <div class="methodology-card">
                    <h4>What AADC Does at Each Step</h4>
                    <p><strong>Step 1 &mdash; CRIF Generation:</strong> Each trade's price function is recorded as an AADC kernel. A single adjoint backward pass extracts all Delta, Vega, and Inflation sensitivities simultaneously (20&ndash;50x vs bump-and-revalue).</p>
                    <p style="margin-top: 8px;"><strong>Step 2 &mdash; SIMM Kernel:</strong> The SIMM aggregation formula (risk weights, intra-bucket correlations, inter-bucket and cross-risk-class aggregation) is recorded as a compact kernel with K aggregated sensitivity inputs (~100 regardless of trade count).</p>
                    <p style="margin-top: 8px;"><strong>Step 3 &mdash; Optimization Loop:</strong> The pre-recorded SIMM kernel is evaluated repeatedly to compute IM/Sensitivity gradients. Each evaluation costs ~1 ms. With v2 batched evaluation, all P portfolios' gradients are computed in a single <code>aadc.evaluate()</code> call, avoiding PythonC++ dispatch overhead.</p>
                    <p style="margin-top: 8px; font-size: 0.85em; color: #888;">The data shown on this page comes from real AADC executions logged to <code>execution_log_portfolio.csv</code>.</p>
                </div>
                <div class="methodology-card" style="grid-column: span 2;">
                    <h4>Supported Greeks</h4>
                    <table class="greeks-table">
                        <thead>
                            <tr>
                                <th>Greek Type</th>
                                <th>Risk Type</th>
                                <th>Description</th>
                                <th>Trade Types</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_IRCurve</td>
                                <td>Interest rate delta by tenor bucket</td>
                                <td>IR Swaps, FX Options, Inflation Swaps, XCCY Swaps</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_FX</td>
                                <td>FX spot delta</td>
                                <td>FX Options, XCCY Swaps</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_Equity</td>
                                <td>Equity spot delta</td>
                                <td>Equity Options</td>
                            </tr>
                            <tr>
                                <td>Delta</td>
                                <td class="risk-type">Risk_Inflation</td>
                                <td>Inflation rate delta</td>
                                <td>Inflation Swaps</td>
                            </tr>
                            <tr>
                                <td>Vega</td>
                                <td class="risk-type">Risk_EquityVol</td>
                                <td>Equity implied volatility sensitivity</td>
                                <td>Equity Options</td>
                            </tr>
                            <tr>
                                <td>Vega</td>
                                <td class="risk-type">Risk_FXVol</td>
                                <td>FX implied volatility sensitivity</td>
                                <td>FX Options</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        </div><!-- end tab-optimizer -->

        <!-- Tab 2: New Trade Analytics -->
        <div id="tab-newtrade" class="main-tab-content">
            <div id="newtrade-loading" style="text-align:center;padding:40px;color:#888;">Loading pre-trade analytics data...</div>
            <div id="newtrade-content" style="display:none;">
                <!-- Portfolio & New Trade Banner -->
                <div id="nt-banner" class="performance-banner" style="margin-bottom:20px;"></div>
                <!-- Marginal IM with AADC Timing -->
                <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;margin-bottom:20px;" id="nt-marginal"></div>
                <!-- Counterparty Routing -->
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;">
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#4fc3f7;margin-bottom:15px;">Counterparty Routing</h3>
                        <div id="nt-routing-table" style="overflow-x:auto;"></div>
                    </div>
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#4fc3f7;margin-bottom:15px;">Bilateral vs Cleared</h3>
                        <div id="nt-bilateral"></div>
                    </div>
                </div>
            </div>
            <div id="newtrade-error" style="display:none;text-align:center;padding:40px;color:#ef5350;">
                No pre-trade data available. Run: <code style="color:#4fc3f7;">python scripts/export_animation_data.py --trades 15 --portfolios 3</code>
            </div>
        </div>

        <!-- Tab 3: What-If Analytics -->
        <div id="tab-whatif" class="main-tab-content">
            <div id="whatif-loading" style="text-align:center;padding:40px;color:#888;">Loading what-if analytics data...</div>
            <div id="whatif-content" style="display:none;">
                <!-- Summary cards -->
                <div id="wi-summary" class="performance-banner" style="margin-bottom:20px;"></div>
                <!-- AADC Performance note -->
                <div id="wi-perf" style="background:rgba(102,187,106,0.08);border:1px solid rgba(102,187,106,0.2);border-radius:12px;padding:20px;margin-bottom:20px;"></div>
                <!-- How It Works explanation -->
                <div id="wi-explanation" style="background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;margin-bottom:20px;border-left:3px solid #4fc3f7;"></div>
                <!-- IM Breakdown by Risk Class -->
                <div id="wi-breakdown-section" style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;margin-bottom:20px;">
                    <h3 style="color:#4fc3f7;margin-bottom:15px;">IM Breakdown by Risk Class</h3>
                    <div id="wi-breakdown" style="overflow-x:auto;"></div>
                </div>
                <!-- Attribution tables side by side -->
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;">
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#ef5350;margin-bottom:15px;">Top Margin Consumers</h3>
                        <div id="wi-consumers" style="overflow-x:auto;"></div>
                    </div>
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#66bb6a;margin-bottom:15px;">Top Margin Reducers</h3>
                        <div id="wi-reducers" style="overflow-x:auto;"></div>
                    </div>
                </div>
                <!-- Counterparty Routing -->
                <div id="wi-routing-section" style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;margin-bottom:20px;">
                    <h3 style="color:#4fc3f7;margin-bottom:15px;">Counterparty Routing</h3>
                    <div id="wi-routing" style="overflow-x:auto;"></div>
                    <div id="wi-routing-note" style="margin-top:12px;"></div>
                </div>
                <!-- IM Ladder (Margin Over Time) -->
                <div id="wi-ladder-section" style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;margin-bottom:20px;">
                    <h3 style="color:#ab47bc;margin-bottom:15px;">IM Ladder &mdash; Margin Over Time</h3>
                    <div id="wi-ladder" style="overflow-x:auto;"></div>
                    <div id="wi-ladder-note" style="margin-top:12px;"></div>
                </div>
                <!-- Scenarios -->
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;">
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#4fc3f7;margin-bottom:15px;">Unwind & Hedge Scenarios</h3>
                        <div id="wi-scenarios"></div>
                    </div>
                    <div style="background:rgba(255,255,255,0.05);border-radius:12px;padding:20px;">
                        <h3 style="color:#ffa726;margin-bottom:15px;">Stress Scenarios</h3>
                        <div id="wi-stress"></div>
                    </div>
                </div>
                <!-- Methodology explanations -->
                <div id="wi-methodology" style="display:grid;grid-template-columns:1fr 1fr;gap:20px;"></div>
            </div>
            <div id="whatif-error" style="display:none;text-align:center;padding:40px;color:#ef5350;">
                No what-if data available. Run: <code style="color:#4fc3f7;">python scripts/export_animation_data.py --trades 15 --portfolios 3</code>
            </div>
        </div>

        <!-- Tab 4: Scaling Benchmarks -->
        <div id="tab-scaling" class="main-tab-content">
            <div id="scaling-loading" style="text-align:center;padding:40px;color:#888;">Loading scaling benchmark data...</div>
            <div id="scaling-content" style="display:none;">

                <!-- Hero banner -->
                <div id="scaling-hero" class="performance-banner" style="margin-bottom:20px;"></div>

                <!-- Sub-tabs for 3 benchmark types -->
                <div style="display:flex;gap:8px;margin-bottom:20px;">
                    <button class="scaling-subtab active" onclick="switchScalingSubtab('gradient', this)" style="padding:8px 16px;border:1px solid #444;border-radius:8px;background:rgba(79,195,247,0.15);color:#4fc3f7;cursor:pointer;font-size:0.9em;">Portfolio Optimization</button>
                    <button class="scaling-subtab" onclick="switchScalingSubtab('pretrade', this)" style="padding:8px 16px;border:1px solid #444;border-radius:8px;background:transparent;color:#aaa;cursor:pointer;font-size:0.9em;">Pre-Trade / New Trade</button>
                    <button class="scaling-subtab" onclick="switchScalingSubtab('whatif', this)" style="padding:8px 16px;border:1px solid #444;border-radius:8px;background:transparent;color:#aaa;cursor:pointer;font-size:0.9em;">Margin Attribution</button>
                </div>

                <!-- Gradient Scaling -->
                <div id="scaling-gradient" class="scaling-panel">
                    <h3 style="color:#4fc3f7;margin-bottom:10px;">Gradient Computation Scaling for Portfolio Optimization</h3>
                    <p style="color:#aaa;margin-bottom:15px;font-size:0.9em;">
                        AADC computes IM/Allocation for <strong>all trades</strong> in a single adjoint pass (O(K) where K~100 risk factors).
                        Bump-and-revalue requires TP separate evaluations  infeasible at scale.
                    </p>
                    <div id="scaling-gradient-table"></div>
                    <div id="scaling-gradient-chart" style="margin-top:20px;"></div>
                    <div id="scaling-gradient-extrapolation" style="margin-top:20px;background:rgba(79,195,247,0.08);border:1px solid rgba(79,195,247,0.2);border-radius:12px;padding:20px;"></div>
                </div>

                <!-- Pre-Trade Scaling -->
                <div id="scaling-pretrade" class="scaling-panel" style="display:none;">
                    <h3 style="color:#4fc3f7;margin-bottom:10px;">Pre-Trade Marginal IM Query Scaling</h3>
                    <p style="color:#aaa;margin-bottom:15px;font-size:0.9em;">
                        AADC pre-computes the gradient once, then each marginal IM query is a simple dot product (O(K)).
                        Without AADC, each query requires a full SIMM recalculation per counterparty.
                    </p>
                    <div id="scaling-pretrade-table"></div>
                    <div id="scaling-pretrade-chart" style="margin-top:20px;"></div>
                    <div id="scaling-pretrade-extrapolation" style="margin-top:20px;background:rgba(79,195,247,0.08);border:1px solid rgba(79,195,247,0.2);border-radius:12px;padding:20px;"></div>
                </div>

                <!-- What-If Scaling -->
                <div id="scaling-whatif" class="scaling-panel" style="display:none;">
                    <h3 style="color:#4fc3f7;margin-bottom:10px;">Margin Attribution Scaling</h3>
                    <p style="color:#aaa;margin-bottom:15px;font-size:0.9em;">
                        AADC computes attribution for <strong>all trades at once</strong> via gradient  sensitivities (O(TK)).
                        Naive leave-one-out requires T separate SIMM evaluations  O(T) total.
                    </p>
                    <div id="scaling-whatif-table"></div>
                    <div id="scaling-whatif-chart" style="margin-top:20px;"></div>
                    <div id="scaling-whatif-extrapolation" style="margin-top:20px;background:rgba(79,195,247,0.08);border:1px solid rgba(79,195,247,0.2);border-radius:12px;padding:20px;"></div>
                </div>

            </div>
            <div id="scaling-error" style="display:none;text-align:center;padding:40px;color:#ef5350;">
                No scaling benchmark data available. Run the benchmark scripts first:<br>
                <code style="color:#4fc3f7;display:block;margin-top:10px;">
                    python scripts/benchmark_1m_gradient_scaling.py<br>
                    python scripts/benchmark_1m_pretrade.py<br>
                    python scripts/benchmark_1m_whatif.py
                </code>
            </div>
        </div>

    </div><!-- end container -->

    <div class="tooltip" id="tooltip"></div>

    <script>
        // ===== Data Loading Layer =====
        async function loadCSV(filename) {
            for (const base of ['data/', '../data/']) {
                try {
                    const resp = await fetch(base + filename);
                    if (resp.ok) return await resp.text();
                } catch(e) {}
            }
            return null;
        }

        async function loadJSON(filename) {
            for (const base of ['data/animation/', '../data/animation/']) {
                try {
                    const resp = await fetch(base + filename);
                    if (resp.ok) return await resp.json();
                } catch(e) {}
            }
            return null;
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = parseCSVLine(lines[0]);
            return lines.slice(1).filter(l => l.trim()).map(line => {
                const vals = parseCSVLine(line);
                const obj = {};
                headers.forEach((h, i) => obj[h.trim()] = (vals[i] || '').trim());
                return obj;
            });
        }

        function parseCSVLine(line) {
            const fields = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (inQuotes) {
                    if (ch === '"') {
                        if (i + 1 < line.length && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = false;
                        }
                    } else {
                        current += ch;
                    }
                } else if (ch === '"') {
                    inQuotes = true;
                } else if (ch === ',') {
                    fields.push(current);
                    current = '';
                } else {
                    current += ch;
                }
            }
            fields.push(current);
            return fields;
        }

        function discoverConfigs(rows) {
            const allRows = rows.filter(r => r.group_id === 'ALL');
            const versions = [...new Set(allRows.map(r => r.model_version))];
            versions.sort();
            const latestVersion = versions[versions.length - 1];

            const configs = {};
            allRows.filter(r => r.model_version === latestVersion).forEach(row => {
                const key = `${row.trade_types}|${row.num_trades}|${row.num_portfolios}`;
                if (!configs[key]) {
                    configs[key] = {
                        trade_types: row.trade_types,
                        num_trades: parseInt(row.num_trades),
                        num_portfolios: parseInt(row.num_portfolios),
                        model_version: row.model_version,
                        runs: [],
                    };
                }
                configs[key].runs.push(row);
            });

            return Object.values(configs).map(cfg => {
                const n = cfg.runs.length;
                const avg = (field) => cfg.runs.reduce((s, r) => s + parseFloat(r[field] || 0), 0) / n;
                // Prefer the latest row with optimize data; fall back to latest row
                const optRuns = cfg.runs.filter(r => r.optimize_initial_im && r.optimize_initial_im.trim());
                const bestRow = optRuns.length > 0 ? optRuns[optRuns.length - 1] : cfg.runs[cfg.runs.length - 1];
                const getField = (field) => bestRow[field] || '';
                const hasOptimize = optRuns.length > 0;
                const result = {
                    ...cfg,
                    num_runs: n,
                    avg_crif_time: avg('crif_time_sec'),
                    avg_simm_time: avg('simm_time_sec'),
                    avg_im_sens_time: avg('im_sens_time_sec'),
                    avg_im: avg('im_result'),
                    num_simm_buckets: parseInt(getField('num_simm_buckets')) || 0,
                    num_im_sensitivities: parseInt(getField('num_im_sensitivities')) || 0,
                };
                if (hasOptimize) {
                    result.optimize = {
                        method: getField('optimize_method'),
                        time_sec: parseFloat(getField('optimize_time_sec')) || 0,
                        initial_im: parseFloat(getField('optimize_initial_im')) || 0,
                        final_im: parseFloat(getField('optimize_final_im')) || 0,
                        trades_moved: parseInt(getField('optimize_trades_moved')) || 0,
                        iterations: parseInt(getField('optimize_iterations')) || 0,
                        im_reduction_pct: parseFloat(getField('optimize_im_reduction_pct')) || 0,
                        converged: getField('optimize_converged') === 'True',
                    };
                }
                return result;
            });
        }

        // Global state for config selection
        let discoveredConfigs = [];
        let allCsvRows = [];

        function populateConfigSelector(configs) {
            discoveredConfigs = configs;
            const container = document.getElementById('configCards');
            container.innerHTML = '';
            configs.forEach((cfg, i) => {
                const card = document.createElement('div');
                card.className = 'config-card' + (i === 0 ? ' active' : '');
                card.dataset.index = i;
                const types = cfg.trade_types.replace(/,/g, ', ');
                card.innerHTML = `
                    <div class="config-card-title">${cfg.num_trades} trades &middot; ${cfg.num_portfolios} portfolios</div>
                    <div class="config-card-detail"><span>${types}</span></div>
                `;
                card.addEventListener('click', () => selectConfig(i));
                container.appendChild(card);
            });
            // Keep hidden dropdown in sync for backward compat
            const dropdown = document.getElementById('configDropdown');
            dropdown.innerHTML = '';
            configs.forEach((cfg, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${cfg.trade_types} | ${cfg.num_trades} trades | ${cfg.num_portfolios} portfolios`;
                dropdown.appendChild(opt);
            });
            document.getElementById('configSelector').style.display = '';
        }

        function selectConfig(idx) {
            document.querySelectorAll('.config-card').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.config-card')[idx].classList.add('active');
            document.getElementById('configDropdown').value = idx;
            viewSelectedConfig();
        }

        function onConfigSelected() {
            // no-op, kept for backward compat
        }

        function showPerfBanner(cfg) {
            const total = cfg.avg_crif_time + cfg.avg_simm_time + cfg.avg_im_sens_time;
            const runLabel = cfg.num_runs > 1 ? `${cfg.num_runs} run avg` : '1 run';
            document.getElementById('perfCrif').textContent = cfg.avg_crif_time.toFixed(2) + 's';
            document.getElementById('perfCrifDetail').textContent = runLabel;
            document.getElementById('perfSimm').textContent = cfg.avg_simm_time.toFixed(2) + 's';
            document.getElementById('perfSimmDetail').textContent = runLabel;
            document.getElementById('perfGrad').textContent = cfg.avg_im_sens_time.toFixed(2) + 's';
            document.getElementById('perfGradDetail').textContent = runLabel;
            document.getElementById('perfTotal').textContent = total.toFixed(2) + 's';
            document.getElementById('perfTotalDetail').textContent =
                `${cfg.num_trades} trades, ${cfg.num_portfolios} portfolios` +
                (cfg.optimize ? ` | Optimize: ${cfg.optimize.time_sec.toFixed(1)}s` : '');
            document.getElementById('perfBanner').style.display = '';
            document.getElementById('perfExplanation').style.display = '';
        }

        async function viewSelectedConfig() {
            const idx = parseInt(document.getElementById('configDropdown').value);
            const cfg = discoveredConfigs[idx];
            if (!cfg) return;

            showPerfBanner(cfg);

            // Try loading optimization.json (full animation data) matching this config
            const optData = await loadJSON('optimization.json');
            if (optData && optData.config &&
                optData.config.num_trades === cfg.num_trades &&
                optData.config.num_portfolios === cfg.num_portfolios) {
                const execTime = optData.performance ? optData.performance.total_time_sec || 0 : 0;
                showAllMovements = false;
                initializeVisualization(optData, true, execTime);
                document.getElementById('pageSubtitle').textContent =
                    `Real AADC execution data: ${cfg.trade_types} | ${cfg.num_trades} trades | ${cfg.num_portfolios} portfolios`;
                return;
            }

            // Try loading per-config optimization history
            const histData = await loadHistoryJSON(cfg);
            showExecutionLogSummary(cfg, histData);
        }

        async function loadHistoryJSON(cfg) {
            // Build per-config filename
            const typesSlug = cfg.trade_types.replace(/,/g, '_');
            const filename = `${typesSlug}_${cfg.num_trades}t_${cfg.num_portfolios}p.json`;
            for (const base of ['data/optimization_history/', '../data/optimization_history/']) {
                try {
                    const resp = await fetch(base + filename);
                    if (resp.ok) return await resp.json();
                } catch(e) {}
            }
            // Fallback: try old single-file location
            for (const base of ['data/', '../data/']) {
                try {
                    const resp = await fetch(base + 'optimization_history.json');
                    if (resp.ok) {
                        const data = await resp.json();
                        if (data.config &&
                            data.config.trade_types === cfg.trade_types &&
                            data.config.num_trades === cfg.num_trades &&
                            data.config.num_portfolios === cfg.num_portfolios) {
                            return data;
                        }
                    }
                } catch(e) {}
            }
            return null;
        }

        // Show/hide sections that require full trade data
        function setTradeDataSectionsVisible(visible) {
            const display = visible ? '' : 'none';
            document.getElementById('crifSection').style.display = display;
            document.getElementById('calcSection').style.display = display;
        }

        function setOptimizationSectionsVisible(visible) {
            const display = visible ? '' : 'none';
            document.getElementById('chartSection').style.display = display;
            document.getElementById('movementSection').style.display = display;
        }

        function showExecutionLogSummary(cfg, histData) {
            document.getElementById('pageSubtitle').textContent =
                `Real AADC execution data: ${cfg.trade_types} | ${cfg.num_trades} trades | ${cfg.num_portfolios} portfolios (v${cfg.model_version})`;

            // Get per-group rows for this config (use latest run's data)
            const groupRows = allCsvRows.filter(r =>
                r.trade_types === cfg.trade_types &&
                r.num_trades === String(cfg.num_trades) &&
                r.num_portfolios === String(cfg.num_portfolios) &&
                r.model_version === cfg.model_version &&
                r.group_id !== 'ALL'
            );

            // Use the latest run's per-group data (all share same timestamp)
            const latestTimestamp = groupRows.length > 0 ?
                groupRows.reduce((latest, r) => r.timestamp > latest ? r.timestamp : latest, '') : '';
            const latestGroupRows = groupRows.filter(r => r.timestamp === latestTimestamp);

            // Build portfolio IM data
            const portfolioIMs = latestGroupRows.map(r => ({
                portfolio: parseInt(r.group_id),
                im: parseFloat(r.im_result || 0),
                trades: parseInt(r.num_group_trades || 0),
                sensitivities: parseInt(r.num_im_sensitivities || 0),
            })).sort((a, b) => a.portfolio - b.portfolio);

            const totalIM = portfolioIMs.reduce((s, p) => s + p.im, 0);
            const totalTime = cfg.avg_crif_time + cfg.avg_simm_time + cfg.avg_im_sens_time;
            const opt = cfg.optimize;

            // Show algorithm explanation when optimization data is available
            document.getElementById('algoExplanation').style.display = opt ? '' : 'none';

            // Update summary section with real data
            if (opt) {
                document.getElementById('initialIM').textContent = formatCurrency(opt.initial_im);
                document.getElementById('finalIM').textContent = formatCurrency(opt.final_im);
                const savings = opt.initial_im - opt.final_im;
                if (savings > 0) {
                    document.getElementById('reduction').textContent = formatPercent(opt.im_reduction_pct);
                    document.getElementById('reduction').className = 'stat-value positive';
                    document.getElementById('totalSavings').textContent = formatCurrency(savings);
                    document.getElementById('totalSavings').className = 'stat-value positive';
                } else if (savings === 0) {
                    document.getElementById('reduction').textContent = 'No change';
                    document.getElementById('reduction').className = 'stat-value';
                    document.getElementById('totalSavings').textContent = '-';
                    document.getElementById('totalSavings').className = 'stat-value';
                } else {
                    document.getElementById('reduction').textContent = formatPercent(opt.im_reduction_pct);
                    document.getElementById('reduction').className = 'stat-value negative';
                    document.getElementById('totalSavings').textContent = formatCurrency(savings);
                    document.getElementById('totalSavings').className = 'stat-value negative';
                }
                document.getElementById('tradesMoved').textContent = opt.trades_moved;
                document.getElementById('iterations').textContent = opt.iterations;
                document.getElementById('execTime').textContent = (totalTime + opt.time_sec).toFixed(2) + 's';
            } else {
                document.getElementById('initialIM').textContent = formatCurrency(totalIM);
                document.getElementById('finalIM').textContent = '-';
                document.getElementById('reduction').textContent = '-';
                document.getElementById('totalSavings').textContent = '-';
                document.getElementById('tradesMoved').textContent = '-';
                document.getElementById('iterations').textContent = '-';
                document.getElementById('execTime').textContent = totalTime.toFixed(2) + 's';
            }
            document.getElementById('maturityInfo').textContent =
                `${cfg.num_im_sensitivities} sens`;
            document.getElementById('maturityInfo').title = 'Total CRIF sensitivities';
            document.getElementById('maturityLabel').textContent = 'Sensitivities';

            // Show portfolio breakdown
            const colors = ['#4fc3f7', '#ab47bc', '#ffa726', '#66bb6a', '#ef5350'];
            let html = '';

            // Determine if we have before/after assignment data from history
            const hasAssignments = histData && histData.initial_assignments && histData.final_assignments;

            if (opt && hasAssignments) {
                document.getElementById('portfolioSectionTitle').textContent = 'Portfolio Comparison: Before vs After';
                html += `<div style="margin-bottom:15px;color:#aaa;font-size:0.9em;">
                    Method: ${opt.method} | ${opt.converged ? 'Converged' : 'Max iterations reached'} | ${opt.trades_moved} trades moved
                </div>`;

                // Count trades per portfolio before and after
                const numP = cfg.num_portfolios;
                const beforeCounts = new Array(numP).fill(0);
                const afterCounts = new Array(numP).fill(0);
                histData.initial_assignments.forEach(p => { if (p >= 0 && p < numP) beforeCounts[p]++; });
                histData.final_assignments.forEach(p => { if (p >= 0 && p < numP) afterCounts[p]++; });

                html += '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">';

                // Before
                html += '<div><h4 style="color:#ef5350;margin-bottom:10px;">Before Optimization</h4><div class="portfolio-grid">';
                for (let p = 0; p < numP; p++) {
                    html += `
                        <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                            <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                            <div class="stat-row"><span class="label">Trades</span><span class="value">${beforeCounts[p]}</span></div>
                        </div>`;
                }
                html += '</div></div>';

                // After
                html += '<div><h4 style="color:#66bb6a;margin-bottom:10px;">After Optimization</h4><div class="portfolio-grid">';
                for (let p = 0; p < numP; p++) {
                    const diff = afterCounts[p] - beforeCounts[p];
                    const diffStr = diff !== 0 ? ` (${diff > 0 ? '+' : ''}${diff})` : '';
                    html += `
                        <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                            <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                            <div class="stat-row"><span class="label">Trades</span><span class="value">${afterCounts[p]}${diffStr}</span></div>
                        </div>`;
                }
                html += '</div></div>';
                html += '</div>';

            } else if (opt) {
                document.getElementById('portfolioSectionTitle').textContent = 'Portfolio Breakdown';
                html += `<div style="margin-bottom:15px;color:#aaa;font-size:0.9em;">
                    Method: ${opt.method} | ${opt.converged ? 'Converged' : 'Max iterations reached'}
                </div>`;
                html += '<div class="portfolio-grid">';
                portfolioIMs.forEach(p => {
                    html += `
                        <div class="portfolio-card" style="border-color: ${colors[p.portfolio % colors.length]}">
                            <h4 style="color: ${colors[p.portfolio % colors.length]}">Portfolio ${p.portfolio + 1}</h4>
                            <div class="stat-row"><span class="label">Trades</span><span class="value">${p.trades}</span></div>
                            <div class="stat-row"><span class="label">IM</span><span class="value">${formatCurrency(p.im)}</span></div>
                        </div>`;
                });
                html += '</div>';
            } else {
                document.getElementById('portfolioSectionTitle').textContent = 'Portfolio Breakdown';
                html += '<div class="portfolio-grid">';
                portfolioIMs.forEach(p => {
                    html += `
                        <div class="portfolio-card" style="border-color: ${colors[p.portfolio % colors.length]}">
                            <h4 style="color: ${colors[p.portfolio % colors.length]}">Portfolio ${p.portfolio + 1}</h4>
                            <div class="stat-row"><span class="label">Trades</span><span class="value">${p.trades}</span></div>
                            <div class="stat-row"><span class="label">IM</span><span class="value">${formatCurrency(p.im)}</span></div>
                            <div class="stat-row"><span class="label">Sensitivities</span><span class="value">${p.sensitivities}</span></div>
                        </div>`;
                });
                html += '</div>';
            }

            // Show timing breakdown
            html += `<div style="margin-top:20px;">
                <div class="portfolio-grid">
                    <div class="portfolio-card" style="border-color:#4fc3f7">
                        <h4 style="color:#4fc3f7">CRIF Generation (AADC)</h4>
                        <div class="stat-row"><span class="label">Time</span><span class="value">${cfg.avg_crif_time.toFixed(3)}s</span></div>
                        <div class="stat-row"><span class="label">Sensitivities</span><span class="value">${cfg.num_im_sensitivities}</span></div>
                    </div>
                    <div class="portfolio-card" style="border-color:#66bb6a">
                        <h4 style="color:#66bb6a">SIMM Aggregation</h4>
                        <div class="stat-row"><span class="label">Time</span><span class="value">${cfg.avg_simm_time.toFixed(3)}s</span></div>
                        <div class="stat-row"><span class="label">Buckets</span><span class="value">${cfg.num_simm_buckets}</span></div>
                    </div>
                    <div class="portfolio-card" style="border-color:#ab47bc">
                        <h4 style="color:#ab47bc">IM Gradient (AAD)</h4>
                        <div class="stat-row"><span class="label">Time</span><span class="value">${cfg.avg_im_sens_time.toFixed(3)}s</span></div>
                    </div>`;
            if (opt) {
                html += `
                    <div class="portfolio-card" style="border-color:#ffa726">
                        <h4 style="color:#ffa726">Optimization</h4>
                        <div class="stat-row"><span class="label">Time</span><span class="value">${opt.time_sec.toFixed(2)}s</span></div>
                        <div class="stat-row"><span class="label">Method</span><span class="value">${opt.method}</span></div>
                        <div class="stat-row"><span class="label">Iterations</span><span class="value">${opt.iterations}</span></div>
                    </div>`;
            }
            html += `</div></div>`;

            html += `<div style="margin-top:15px;padding:15px;background:rgba(255,167,38,0.1);border-left:3px solid #ffa726;border-radius:4px;font-size:0.85em;color:#ffa726;">
                To generate full visualization data (trade movements, animation) for this config:<br>
                <code style="color:#4fc3f7;">python scripts/export_animation_data.py --trades ${cfg.num_trades} --portfolios ${cfg.num_portfolios} --trade-types ${cfg.trade_types}</code>
            </div>`;

            portfoliosContainer.innerHTML = html;

            // Hide CRIF/calc sections (no trade-level data from execution log)
            setTradeDataSectionsVisible(false);

            // Chart and movement log from history data
            if (histData && histData.im_history && histData.im_history.length > 0) {
                setOptimizationSectionsVisible(true);
                // Build chart from im_history
                const steps = histData.im_history.map((im, i) => ({ iteration: i, total_im: im }));
                updateChart({ optimization: { steps } });

                // Add note if continuous relaxation found improvement but no discrete moves happened
                const histTradesMoved = histData.trades_moved || (histData.movements ? histData.movements.length : 0);
                if (histTradesMoved === 0) {
                    document.querySelector('#chartSection .chart-title').textContent =
                        'Continuous Relaxation IM (no discrete trades moved)';
                } else {
                    document.querySelector('#chartSection .chart-title').textContent =
                        'Total IM Over Iterations';
                }

                // Show movements
                if (histData.movements && histData.movements.length > 0) {
                    showAllMovements = false;
                    updateMovementLog(histData.movements.map(m => ({
                        trade_id: m.trade_id,
                        from_portfolio: m.from_portfolio,
                        to_portfolio: m.to_portfolio,
                        standalone_im: 0,
                    })));
                } else {
                    movementLog.innerHTML = '<p style="color: #666;">No trade movements -- continuous relaxation did not produce discrete improvements</p>';
                }
            } else {
                // No history data -- hide chart and movement log too
                setOptimizationSectionsVisible(cfg.optimize ? true : false);
                document.getElementById('chartPath').setAttribute('d', '');
                document.getElementById('chartArea').setAttribute('d', '');
                movementLog.innerHTML = '<p style="color: #666;">Run with <code>--optimize</code> to generate per-iteration data</p>';
            }

            // Update progress bar
            progressFill.style.width = '100%';
            progressText.textContent = opt ?
                `Optimization: ${formatPercent(opt.im_reduction_pct)} IM reduction in ${opt.iterations} iterations` :
                'Execution log data loaded';
        }

        // Manual mode removed - static deployment only shows real execution data

        // SIMM Parameters (ISDA v2.6) - Now with intra-bucket correlations
        const SIMM_PARAMS = {
            version: '2.6',
            irTenors: ['2W', '1M', '3M', '6M', '1Y', '2Y', '3Y', '5Y', '10Y', '15Y', '20Y', '30Y'],
            // Currency-specific IR risk weights (regular volatility currencies)
            irWeights: {
                'regular': [77, 77, 68, 56, 52, 50, 51, 52, 50, 51, 51, 64],
                'low': [15, 19, 9, 11, 15, 22, 22, 23, 21, 19, 20, 23],      // JPY, etc.
                'high': [116, 116, 107, 93, 87, 91, 92, 97, 102, 101, 106, 101] // BRL, etc.
            },
            lowVolCurrencies: ['JPY'],
            highVolCurrencies: ['BRL', 'TRY', 'ZAR', 'MXN', 'RUB'],
            // IR tenor correlation matrix (12x12) - ISDA v2.6
            irCorrelation: [
                [1.00, 0.99, 0.94, 0.87, 0.77, 0.67, 0.61, 0.52, 0.41, 0.35, 0.29, 0.20],
                [0.99, 1.00, 0.97, 0.91, 0.81, 0.72, 0.66, 0.58, 0.47, 0.40, 0.34, 0.25],
                [0.94, 0.97, 1.00, 0.97, 0.90, 0.82, 0.76, 0.68, 0.56, 0.49, 0.42, 0.32],
                [0.87, 0.91, 0.97, 1.00, 0.96, 0.90, 0.85, 0.77, 0.65, 0.57, 0.50, 0.39],
                [0.77, 0.81, 0.90, 0.96, 1.00, 0.97, 0.94, 0.87, 0.76, 0.68, 0.60, 0.48],
                [0.67, 0.72, 0.82, 0.90, 0.97, 1.00, 0.98, 0.94, 0.85, 0.77, 0.69, 0.56],
                [0.61, 0.66, 0.76, 0.85, 0.94, 0.98, 1.00, 0.97, 0.90, 0.83, 0.75, 0.62],
                [0.52, 0.58, 0.68, 0.77, 0.87, 0.94, 0.97, 1.00, 0.95, 0.90, 0.83, 0.70],
                [0.41, 0.47, 0.56, 0.65, 0.76, 0.85, 0.90, 0.95, 1.00, 0.97, 0.93, 0.82],
                [0.35, 0.40, 0.49, 0.57, 0.68, 0.77, 0.83, 0.90, 0.97, 1.00, 0.98, 0.89],
                [0.29, 0.34, 0.42, 0.50, 0.60, 0.69, 0.75, 0.83, 0.93, 0.98, 1.00, 0.94],
                [0.20, 0.25, 0.32, 0.39, 0.48, 0.56, 0.62, 0.70, 0.82, 0.89, 0.94, 1.00]
            ],
            otherWeights: {
                'FX': 8.4,
                'FX Vol': 4.6,
                'Equity': 25.0,
                'Equity Vol': 28.0,
                'Inflation': 63.0,
                'Credit': 85.0,
                'Commodity': 40.0
            },
            // Intra-bucket correlations for other risk classes
            intraCorrelations: {
                'Equity': 0.25,
                'Commodity': 0.50,
                'FX': 0.50,
                'CreditQ': 0.50,
                'CreditNonQ': 0.50
            },
            riskClasses: ['Rates', 'CreditQ', 'CreditNonQ', 'Equity', 'Commodity', 'FX'],
            psiMatrix: [
                [1.00, 0.04, 0.04, 0.07, 0.37, 0.14],
                [0.04, 1.00, 0.54, 0.70, 0.27, 0.37],
                [0.04, 0.54, 1.00, 0.46, 0.24, 0.15],
                [0.07, 0.70, 0.46, 1.00, 0.35, 0.39],
                [0.37, 0.27, 0.24, 0.35, 1.00, 0.35],
                [0.14, 0.37, 0.15, 0.39, 0.35, 1.00]
            ]
        };

        // Get IR risk weight based on currency volatility bucket
        function getIRRiskWeight(currency, tenorIdx) {
            if (SIMM_PARAMS.lowVolCurrencies.includes(currency)) {
                return SIMM_PARAMS.irWeights.low[tenorIdx];
            } else if (SIMM_PARAMS.highVolCurrencies.includes(currency)) {
                return SIMM_PARAMS.irWeights.high[tenorIdx];
            }
            return SIMM_PARAMS.irWeights.regular[tenorIdx];
        }

        // Get IR tenor correlation
        function getIRCorrelation(tenorIdx1, tenorIdx2) {
            return SIMM_PARAMS.irCorrelation[tenorIdx1][tenorIdx2];
        }

        // Global state
        let demoData = null;
        const LARGE_DATASET_THRESHOLD = 100; // Show extra loading message for large datasets
        // Track execution time
        let lastExecutionTime = 0;

        // DOM elements
        const portfoliosContainer = document.getElementById('portfoliosContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const movementLog = document.getElementById('movementLog');
        const tooltip = document.getElementById('tooltip');

        // Format currency
        function formatCurrency(value) {
            if (value >= 1e9) {
                return '$' + (value / 1e9).toFixed(2) + 'B';
            } else if (value >= 1e6) {
                return '$' + (value / 1e6).toFixed(2) + 'M';
            } else if (value >= 1e3) {
                return '$' + (value / 1e3).toFixed(2) + 'K';
            }
            return '$' + value.toFixed(2);
        }

        // Format percentage
        function formatPercent(value) {
            return value.toFixed(1) + '%';
        }

        // Map checkbox values to display names
        const tradeTypeMap = {
            'ir_swap': 'IRSwap',
            'equity_option': 'EquityOption',
            'fx_option': 'FXOption',
            'inflation_swap': 'InflationSwap',
            'xccy_swap': 'XCCYSwap'
        };

        // Sample data generator (for demo without backend)
        function generateSampleData(numTrades, numPortfolios, avgMaturity = null, maturitySpread = null) {
            // Get parameters from inputs if not provided
            if (avgMaturity === null) {
                avgMaturity = parseFloat(document.getElementById('avgMaturity').value) || 5;
            }
            if (maturitySpread === null) {
                maturitySpread = parseFloat(document.getElementById('maturitySpread').value) || 1;
            }

            // Get selected trade types
            const selectedTypes = getSelectedTradeTypes().split(',').map(t => tradeTypeMap[t] || 'IRSwap');
            const tradeTypes = selectedTypes.length > 0 ? selectedTypes : ['IRSwap'];
            const currencies = ['USD', 'EUR', 'GBP', 'JPY'];

            const trades = [];
            const padWidth = Math.max(3, String(numTrades).length);
            for (let i = 0; i < numTrades; i++) {
                // Generate maturity around the average with specified spread
                const minMat = Math.max(0.25, avgMaturity - maturitySpread);
                const maxMat = Math.min(30, avgMaturity + maturitySpread);
                const maturity = minMat + Math.random() * (maxMat - minMat);

                // Generate SIGNED sensitivity for netting - key for realistic optimization
                // ~50% positive (pay fixed/long), ~50% negative (receive fixed/short)
                const direction = Math.random() > 0.5 ? 1 : -1;
                const baseSens = (Math.random() * 5000000000 + 100000000) * direction;

                trades.push({
                    id: `TRADE_${String(i).padStart(padWidth, '0')}`,
                    type: tradeTypes[Math.floor(Math.random() * tradeTypes.length)],
                    notional: Math.random() * 100000000 + 10000000,
                    currency: currencies[Math.floor(Math.random() * currencies.length)],
                    maturity: maturity,
                    sensitivity: baseSens,  // Signed sensitivity for netting
                    standalone_im: Math.abs(baseSens),  // Standalone IM is absolute
                    initial_portfolio: Math.floor(Math.random() * numPortfolios),
                    num_sensitivities: Math.floor(Math.random() * 20) + 5,
                });
            }

            // Generate optimization steps - IM only changes when trades move
            const steps = [];
            let currentAssignments = trades.map(t => t.initial_portfolio);

            // OPTIMIZED: Pre-compute portfolio aggregates for O(1) IM updates
            // Track both signed sensitivity sum (for netting) and absolute sum (for standalone)
            const portfolioSums = new Array(numPortfolios).fill(0).map(() => ({
                sensSum: 0,      // Sum of signed sensitivities (can net to zero)
                absSum: 0,       // Sum of absolute sensitivities (standalone total)
                sqSum: 0,        // Sum of squared sensitivities
                count: 0
            }));
            for (let t = 0; t < numTrades; t++) {
                const p = currentAssignments[t];
                const sens = trades[t].sensitivity;
                portfolioSums[p].sensSum += sens;
                portfolioSums[p].absSum += Math.abs(sens);
                portfolioSums[p].sqSum += sens * sens;
                portfolioSums[p].count++;
            }

            // Calculate IM using SIMM-like netting model
            // Key insight: IM = sqrt(sum of squares) with correlation benefit
            // When opposite sensitivities are grouped, they partially cancel
            function calcTotalIMFast() {
                let total = 0;
                for (let p = 0; p < numPortfolios; p++) {
                    if (portfolioSums[p].count === 0) continue;
                    // SIMM-like formula: blend of netted and gross
                    // - |sensSum| captures netting benefit (opposite signs cancel)
                    // - sqrt(sqSum) captures diversification
                    // - absSum is the no-netting baseline
                    const netted = Math.abs(portfolioSums[p].sensSum);
                    const diversified = Math.sqrt(portfolioSums[p].sqSum);
                    // Use 40% netted + 60% diversified - realistic SIMM-like blend
                    const portfolioIM = 0.4 * netted + 0.6 * diversified;
                    total += portfolioIM;
                }
                return total;
            }

            // Update sums when moving a trade - O(1)
            function moveTrade(tradeIdx, fromP, toP) {
                const sens = trades[tradeIdx].sensitivity;
                const absSens = Math.abs(sens);
                portfolioSums[fromP].sensSum -= sens;
                portfolioSums[fromP].absSum -= absSens;
                portfolioSums[fromP].sqSum -= sens * sens;
                portfolioSums[fromP].count--;
                portfolioSums[toP].sensSum += sens;
                portfolioSums[toP].absSum += absSens;
                portfolioSums[toP].sqSum += sens * sens;
                portfolioSums[toP].count++;
            }

            let totalIM = calcTotalIMFast();
            const initialIM = totalIM;
            const totalSteps = 30;

            // For large datasets, use sign-based clustering optimization
            // Key insight: netting benefits come from grouping opposite-sign trades
            // Strategy: designate some portfolios for positive sens, others for negative

            if (numTrades > 1000) {
                // LARGE DATASET OPTIMIZATION
                // Key insight: netting benefit comes from PAIRING opposite-sign trades
                // IM = 0.4 * |sensSum| + 0.6 * sqrt(sqSum)
                // When opposite signs cancel, |sensSum|  0, reducing IM

                // Phase 1: Pair positive and negative trades for maximum netting
                // Sort trades by sensitivity (most negative to most positive)
                const sortedTrades = trades.map((t, i) => ({
                    idx: i,
                    sens: t.sensitivity
                })).sort((a, b) => a.sens - b.sens);

                // Pair from both ends: most negative with most positive
                // Assign paired trades to same portfolio for cancellation
                const numPairs = Math.floor(sortedTrades.length / 2);
                for (let i = 0; i < numPairs; i++) {
                    const negTrade = sortedTrades[i].idx;
                    const posTrade = sortedTrades[sortedTrades.length - 1 - i].idx;
                    const targetPortfolio = i % numPortfolios;

                    // Move negative trade
                    const oldPNeg = currentAssignments[negTrade];
                    if (oldPNeg !== targetPortfolio) {
                        moveTrade(negTrade, oldPNeg, targetPortfolio);
                        currentAssignments[negTrade] = targetPortfolio;
                    }

                    // Move positive trade to same portfolio
                    const oldPPos = currentAssignments[posTrade];
                    if (oldPPos !== targetPortfolio) {
                        moveTrade(posTrade, oldPPos, targetPortfolio);
                        currentAssignments[posTrade] = targetPortfolio;
                    }
                }

                // Handle odd trade if any
                if (sortedTrades.length % 2 === 1) {
                    const midTrade = sortedTrades[numPairs].idx;
                    // Leave in current portfolio or assign to least loaded
                }

                const afterClusteringIM = calcTotalIMFast();

                // Record clustering phase
                for (let s = 0; s < 15; s++) {
                    const progress = s / 14;
                    steps.push({
                        iteration: s,
                        total_im: initialIM + (afterClusteringIM - initialIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }
                totalIM = afterClusteringIM;

                // Phase 2: Fine-tuning with greedy moves on high-impact trades
                const tradesByImpact = trades.map((t, i) => ({
                    idx: i,
                    absSens: Math.abs(t.sensitivity)
                })).sort((a, b) => b.absSens - a.absSens);

                const fineTuneTrades = tradesByImpact.slice(0, Math.min(1000, numTrades)).map(t => t.idx);

                fineTuneTrades.forEach(t => {
                    const currentP = currentAssignments[t];
                    let bestP = currentP;
                    let bestIM = totalIM;

                    for (let p = 0; p < numPortfolios; p++) {
                        if (p === currentP) continue;
                        moveTrade(t, currentP, p);
                        const newIM = calcTotalIMFast();
                        if (newIM < bestIM) {
                            bestIM = newIM;
                            bestP = p;
                        }
                        moveTrade(t, p, currentP);
                    }

                    if (bestP !== currentP && bestIM < totalIM) {
                        moveTrade(t, currentP, bestP);
                        currentAssignments[t] = bestP;
                        totalIM = bestIM;
                    }
                });

                // Record fine-tuning phase
                const afterFineTuneIM = totalIM;
                for (let s = 15; s < totalSteps; s++) {
                    const progress = (s - 15) / (totalSteps - 15);
                    steps.push({
                        iteration: s,
                        total_im: afterClusteringIM + (afterFineTuneIM - afterClusteringIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }

            } else {
                // SMALL DATASET OPTIMIZATION - original greedy approach
                const tradesByImpact = trades.map((t, i) => ({
                    idx: i,
                    absSens: Math.abs(t.sensitivity)
                })).sort((a, b) => b.absSens - a.absSens);

                const maxTradesToEvaluate = Math.min(numTrades, 500);
                const tradeIndicesToEvaluate = tradesByImpact
                    .slice(0, maxTradesToEvaluate)
                    .map(t => t.idx);

                // Multiple greedy passes
                for (let pass = 0; pass < 3; pass++) {
                    tradeIndicesToEvaluate.forEach(t => {
                        const currentP = currentAssignments[t];
                        let bestP = currentP;
                        let bestIM = totalIM;

                        for (let p = 0; p < numPortfolios; p++) {
                            if (p === currentP) continue;
                            moveTrade(t, currentP, p);
                            const newIM = calcTotalIMFast();
                            if (newIM < bestIM) {
                                bestIM = newIM;
                                bestP = p;
                            }
                            moveTrade(t, p, currentP);
                        }

                        if (bestP !== currentP && bestIM < totalIM) {
                            moveTrade(t, currentP, bestP);
                            currentAssignments[t] = bestP;
                            totalIM = bestIM;
                        }
                    });
                }

                // Record steps
                for (let s = 0; s < totalSteps; s++) {
                    const progress = s / (totalSteps - 1);
                    steps.push({
                        iteration: s,
                        total_im: initialIM + (totalIM - initialIM) * progress,
                        assignments: [...currentAssignments],
                    });
                }
            }

            // Calculate portfolio IMs - using same netting model as optimization
            function calcPortfolioIMs(assignments) {
                // Build sums per portfolio in O(T)
                const pData = new Array(numPortfolios).fill(0).map(() => ({
                    sensSum: 0, sqSum: 0, count: 0
                }));
                for (let t = 0; t < numTrades; t++) {
                    const p = assignments[t];
                    const sens = trades[t].sensitivity;
                    pData[p].sensSum += sens;
                    pData[p].sqSum += sens * sens;
                    pData[p].count++;
                }

                const portfolioIMs = [];
                for (let p = 0; p < numPortfolios; p++) {
                    // Same SIMM-like formula as optimization
                    const netted = Math.abs(pData[p].sensSum);
                    const diversified = Math.sqrt(pData[p].sqSum);
                    const portfolioIM = 0.4 * netted + 0.6 * diversified;
                    portfolioIMs.push({
                        portfolio: p,
                        im: portfolioIM,
                        trades: pData[p].count,
                    });
                }
                return portfolioIMs;
            }

            const initialAssignments = trades.map(t => t.initial_portfolio);
            const finalAssignments = steps[steps.length - 1].assignments;

            // Find movements
            const movements = [];
            for (let i = 0; i < numTrades; i++) {
                if (initialAssignments[i] !== finalAssignments[i]) {
                    movements.push({
                        trade_id: trades[i].id,
                        from_portfolio: initialAssignments[i],
                        to_portfolio: finalAssignments[i],
                        standalone_im: trades[i].standalone_im,
                    });
                }
            }

            const initialPortfolioIMs = calcPortfolioIMs(initialAssignments);
            const finalPortfolioIMs = calcPortfolioIMs(finalAssignments);
            const initialTotalIM = initialPortfolioIMs.reduce((s, p) => s + p.im, 0);
            const finalTotalIM = finalPortfolioIMs.reduce((s, p) => s + p.im, 0);

            // Compute maturity stats
            const maturities = trades.map(t => t.maturity);
            const actualAvgMaturity = maturities.reduce((a, b) => a + b, 0) / maturities.length;
            const minMaturity = Math.min(...maturities);
            const maxMaturity = Math.max(...maturities);

            return {
                config: {
                    num_trades: numTrades,
                    num_portfolios: numPortfolios,
                    trade_types: 'Mixed',
                    num_risk_factors: Math.floor(Math.random() * 30) + 10,
                    avg_maturity: Math.round(actualAvgMaturity * 100) / 100,
                    maturity_range: [Math.round(minMaturity * 100) / 100, Math.round(maxMaturity * 100) / 100],
                },
                trades: trades,
                initial_state: {
                    assignments: initialAssignments,
                    portfolio_ims: initialPortfolioIMs,
                    total_im: initialTotalIM,
                },
                final_state: {
                    assignments: finalAssignments,
                    portfolio_ims: finalPortfolioIMs,
                    total_im: finalTotalIM,
                },
                optimization: {
                    num_iterations: steps.length,
                    steps: steps,
                    movements: movements,
                    im_reduction_pct: (1 - finalTotalIM / initialTotalIM) * 100,
                },
            };
        }

        // Track if using real backend (continuous optimization)
        let isRealBackend = false;

        // Initialize visualization with data
        function initializeVisualization(data, fromBackend = false, execTime = 0) {
            demoData = data;
            isRealBackend = fromBackend;
            lastExecutionTime = execTime;

            // Show all sections (they may have been hidden by execution log view)
            setTradeDataSectionsVisible(true);
            setOptimizationSectionsVisible(true);

            // Show/hide optimization note and algorithm explanation
            document.getElementById('optimizationNote').style.display = fromBackend ? 'block' : 'none';
            document.getElementById('algoExplanation').style.display = '';

            // Update stats
            const totalSavings = data.initial_state.total_im - data.final_state.total_im;
            document.getElementById('initialIM').textContent = formatCurrency(data.initial_state.total_im);
            document.getElementById('finalIM').textContent = formatCurrency(data.final_state.total_im);
            document.getElementById('reduction').textContent = formatPercent(data.optimization.im_reduction_pct);
            document.getElementById('totalSavings').textContent = formatCurrency(totalSavings);
            document.getElementById('tradesMoved').textContent = data.optimization.movements.length;
            document.getElementById('iterations').textContent = data.optimization.num_iterations;
            document.getElementById('execTime').textContent = execTime.toFixed(2) + 's';

            // Display maturity info
            if (data.config.avg_maturity !== undefined) {
                const range = data.config.maturity_range || [data.config.avg_maturity, data.config.avg_maturity];
                document.getElementById('maturityInfo').textContent = `${data.config.avg_maturity.toFixed(1)}Y`;
                document.getElementById('maturityInfo').title = `Range: ${range[0].toFixed(1)}Y - ${range[1].toFixed(1)}Y`;
                document.getElementById('maturityLabel').textContent = 'Avg Maturity';
            }

            // Show progress bar at 100%
            progressFill.style.width = '100%';
            progressText.textContent = `Completed - ${data.optimization.num_iterations} iterations`;

            // Create before/after comparison view
            createBeforeAfterView(data);

            // Update chart
            updateChart(data);

            // Populate CRIF and calculation details
            populateCRIFDetails(data);

            // Update movement log
            updateMovementLog(data.optimization.movements);
        }

        // Create before/after portfolio comparison view
        function createBeforeAfterView(data) {
            const colors = ['#4fc3f7', '#ab47bc', '#ffa726', '#66bb6a', '#ef5350'];
            const numPortfolios = data.config.num_portfolios;

            // Pre-compute trade type counts per portfolio for both states
            const beforeTypeCounts = {};
            const afterTypeCounts = {};
            for (let p = 0; p < numPortfolios; p++) {
                beforeTypeCounts[p] = {};
                afterTypeCounts[p] = {};
            }
            data.trades.forEach((t, i) => {
                const beforeP = data.initial_state.assignments[i];
                const afterP = data.final_state.assignments[i];
                beforeTypeCounts[beforeP][t.type] = (beforeTypeCounts[beforeP][t.type] || 0) + 1;
                afterTypeCounts[afterP][t.type] = (afterTypeCounts[afterP][t.type] || 0) + 1;
            });

            let html = `
                <div class="comparison-container">
                    <div class="comparison-section before">
                        <h3>BEFORE Optimization</h3>
                        <div class="total-im">Total IM: ${formatCurrency(data.initial_state.total_im)}</div>
                        <div class="portfolio-grid">
            `;

            // Before portfolios
            for (let p = 0; p < numPortfolios; p++) {
                const pData = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const typeStr = Object.entries(beforeTypeCounts[p])
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ') || 'No trades';

                html += `
                    <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                        <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                        <div class="stat-row">
                            <span class="label">Trades</span>
                            <span class="value">${pData.trades}</span>
                        </div>
                        <div class="stat-row">
                            <span class="label">IM</span>
                            <span class="value">${formatCurrency(pData.im)}</span>
                        </div>
                        <div class="stat-row" style="font-size: 0.8em; color: #666;">
                            ${typeStr}
                        </div>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                    <div class="comparison-section after">
                        <h3>AFTER Optimization</h3>
                        <div class="total-im">Total IM: ${formatCurrency(data.final_state.total_im)}</div>
                        <div class="portfolio-grid">
            `;

            // After portfolios with change indicators
            for (let p = 0; p < numPortfolios; p++) {
                const beforeData = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const afterData = data.final_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const typeStr = Object.entries(afterTypeCounts[p])
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ') || 'No trades';

                const imChange = afterData.im - beforeData.im;
                const tradeChange = afterData.trades - beforeData.trades;
                const imChangeClass = imChange <= 0 ? 'positive' : 'negative';
                const tradeChangeStr = tradeChange > 0 ? `+${tradeChange}` : tradeChange.toString();

                html += `
                    <div class="portfolio-card" style="border-color: ${colors[p % colors.length]}">
                        <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                        <div class="stat-row">
                            <span class="label">Trades</span>
                            <span class="value">${afterData.trades} <span style="color: #888; font-size: 0.85em;">(${tradeChangeStr})</span></span>
                        </div>
                        <div class="stat-row">
                            <span class="label">IM</span>
                            <span class="value">${formatCurrency(afterData.im)}</span>
                        </div>
                        <div class="stat-row" style="font-size: 0.8em; color: #666;">
                            ${typeStr}
                        </div>
                        <div class="change ${imChangeClass}">
                            ${imChange <= 0 ? '' : ''} ${formatCurrency(Math.abs(imChange))}
                        </div>
                    </div>
                `;
            }

            html += `
                        </div>
                    </div>
                </div>
            `;

            // Note: Summary is now at the top of the page (in the summary-section)

            portfoliosContainer.innerHTML = html;
        }

        // Create summary view for large datasets
        function createPortfolioSummaryView(data) {
            const colors = ['#4fc3f7', '#ab47bc', '#ffa726', '#66bb6a', '#ef5350'];
            let html = '';

            // Large dataset notice
            html += `
                <div class="large-dataset-notice">
                    <div class="icon"></div>
                    <div class="text">
                        <h4>Large Dataset Mode</h4>
                        <p>${data.config.num_trades} trades across ${data.config.num_portfolios} portfolios.
                           Individual trade animations disabled for performance.
                           See summary below and detailed breakdown in collapsible sections.</p>
                    </div>
                </div>
            `;

            // Pre-compute trade type counts per portfolio in O(T) instead of O(TP)
            const typeCountByPortfolio = {};
            for (let p = 0; p < data.config.num_portfolios; p++) {
                typeCountByPortfolio[p] = {};
            }
            data.trades.forEach((t, i) => {
                const p = data.final_state.assignments[i];
                typeCountByPortfolio[p][t.type] = (typeCountByPortfolio[p][t.type] || 0) + 1;
            });

            // Summary for each portfolio - comparing initial vs final
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">';

            for (let p = 0; p < data.config.num_portfolios; p++) {
                const initialP = data.initial_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};
                const finalP = data.final_state.portfolio_ims.find(x => x.portfolio === p) || {im: 0, trades: 0};

                const typeCount = typeCountByPortfolio[p];

                const imChange = finalP.im - initialP.im;
                const imChangeClass = imChange <= 0 ? 'positive' : 'negative';
                const tradesChange = finalP.trades - initialP.trades;
                const tradesChangeStr = tradesChange > 0 ? `+${tradesChange}` : tradesChange.toString();

                html += `
                    <div class="portfolio-summary">
                        <div class="portfolio-summary-header">
                            <h4 style="color: ${colors[p % colors.length]}">Portfolio ${p + 1}</h4>
                            <span style="color: #888;">Final State</span>
                        </div>
                        <div class="portfolio-summary-stats">
                            <div class="summary-stat">
                                <div class="value">${finalP.trades}</div>
                                <div class="label">Trades (${tradesChangeStr})</div>
                            </div>
                            <div class="summary-stat">
                                <div class="value">${formatCurrency(finalP.im)}</div>
                                <div class="label">Final IM</div>
                            </div>
                            <div class="summary-stat">
                                <div class="value ${imChangeClass}">${formatCurrency(Math.abs(imChange))}</div>
                                <div class="label">${imChange <= 0 ? 'Reduction' : 'Increase'}</div>
                            </div>
                        </div>
                        <div class="trade-type-breakdown">
                            ${Object.entries(typeCount).map(([type, count]) =>
                                `<span class="trade-type-badge">${type}: ${count}</span>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';

            // Note: Overall summary is now at the top of the page (in the summary-section)

            portfoliosContainer.innerHTML = html;
        }

        // Update chart
        function updateChart(data) {
            const steps = data.optimization.steps;
            const chartPath = document.getElementById('chartPath');
            const chartArea = document.getElementById('chartArea');
            const chartRawPath = document.getElementById('chartRawPath');

            if (steps.length === 0) return;

            // Compute best-so-far (running minimum)
            const rawIMs = steps.map(s => s.total_im);
            const bestSoFar = [];
            let best = rawIMs[0];
            for (let i = 0; i < rawIMs.length; i++) {
                best = Math.min(best, rawIMs[i]);
                bestSoFar.push(best);
            }

            // Use best-so-far range for Y axis
            const allValues = rawIMs.concat(bestSoFar);
            const maxIM = Math.max(...allValues);
            const minIM = Math.min(...allValues);
            const range = maxIM - minIM || 1;

            const width = 800;
            const height = 150;
            const padding = 10;

            function toXY(i, im) {
                const x = padding + (i / (steps.length - 1 || 1)) * (width - 2 * padding);
                const y = height - padding - ((im - minIM) / range) * (height - 2 * padding);
                return { x, y };
            }

            // Raw values path (faded)
            let rawD = '';
            rawIMs.forEach((im, i) => {
                const { x, y } = toXY(i, im);
                rawD += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
            });

            // Best-so-far path (main line) and area
            let bestD = '';
            let areaD = `M ${padding} ${height - padding}`;
            bestSoFar.forEach((im, i) => {
                const { x, y } = toXY(i, im);
                bestD += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
                areaD += ` L ${x} ${y}`;
            });
            areaD += ` L ${width - padding} ${height - padding} Z`;

            chartRawPath.setAttribute('d', rawD);
            chartPath.setAttribute('d', bestD);
            chartArea.setAttribute('d', areaD);

            // Labels
            document.getElementById('chartLabelStart').textContent = formatCurrency(rawIMs[0]);
            document.getElementById('chartLabelEnd').textContent = formatCurrency(bestSoFar[bestSoFar.length - 1]);
        }

        // Update movement log
        const MAX_VISIBLE_MOVEMENTS = 50;
        let showAllMovements = false;

        function updateMovementLog(movements) {
            if (movements.length === 0) {
                movementLog.innerHTML = '<p style="color: #666;">No trade movements in optimization</p>';
                return;
            }

            const displayCount = showAllMovements ? movements.length : Math.min(movements.length, MAX_VISIBLE_MOVEMENTS);
            const hiddenCount = movements.length - displayCount;

            let html = '';
            for (let i = 0; i < displayCount; i++) {
                const m = movements[i];
                html += `
                    <div class="movement-entry">
                        <span class="trade-name">${m.trade_id}</span>
                        <span class="portfolio-badge from">P${m.from_portfolio + 1}</span>
                        <span class="arrow"></span>
                        <span class="portfolio-badge to">P${m.to_portfolio + 1}</span>
                        <span style="color: #888; margin-left: auto;">IM: ${formatCurrency(m.standalone_im)}</span>
                    </div>
                `;
            }

            if (hiddenCount > 0 && !showAllMovements) {
                html += `
                    <div class="movement-entry" style="justify-content: center; cursor: pointer; background: rgba(79, 195, 247, 0.1);"
                         onclick="showAllMovements = true; updateMovementLog(demoData.optimization.movements);">
                        <span style="color: #4fc3f7;">Show ${hiddenCount} more movements...</span>
                    </div>
                `;
            } else if (movements.length > MAX_VISIBLE_MOVEMENTS && showAllMovements) {
                html += `
                    <div class="movement-entry" style="justify-content: center; cursor: pointer; background: rgba(79, 195, 247, 0.1);"
                         onclick="showAllMovements = false; updateMovementLog(demoData.optimization.movements);">
                        <span style="color: #4fc3f7;">Show less</span>
                    </div>
                `;
            }

            movementLog.innerHTML = html;
        }

        // Event listeners
        // Get selected trade types from checkboxes
        function getSelectedTradeTypes() {
            const checkboxes = document.querySelectorAll('.checkbox-group input[type="checkbox"]:checked');
            const types = Array.from(checkboxes).map(cb => cb.value);
            return types.length > 0 ? types.join(',') : 'ir_swap';
        }

        // Toggle details sections
        function toggleDetails(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '';
            } else {
                content.style.display = 'none';
                icon.textContent = '+';
            }
        }

        // Initialize SIMM parameters display
        function initializeSIMMParams() {
            // IR Weights table - show currency-specific weights
            let irHtml = '<tr><th>Tenor</th><th>Regular</th><th>Low Vol</th><th>High Vol</th></tr>';
            SIMM_PARAMS.irTenors.forEach((tenor, i) => {
                const regW = SIMM_PARAMS.irWeights.regular[i];
                const lowW = SIMM_PARAMS.irWeights.low[i];
                const highW = SIMM_PARAMS.irWeights.high[i];
                irHtml += `<tr><td>${tenor}</td><td class="num">${regW}</td><td class="num" style="color:#4fc3f7">${lowW}</td><td class="num" style="color:#f44336">${highW}</td></tr>`;
            });
            irHtml += `<tr style="font-size:0.75em;color:#888"><td colspan="4">Low: ${SIMM_PARAMS.lowVolCurrencies.join(', ')} | High: ${SIMM_PARAMS.highVolCurrencies.join(', ')}</td></tr>`;
            document.getElementById('irWeightsTable').innerHTML = irHtml;

            // Other weights table
            let otherHtml = '';
            Object.entries(SIMM_PARAMS.otherWeights).forEach(([type, weight]) => {
                const intraCorr = SIMM_PARAMS.intraCorrelations[type.replace(' Vol', '')] || '-';
                otherHtml += `<tr><td>${type}</td><td class="num">${weight}</td></tr>`;
            });
            document.getElementById('otherWeightsTable').innerHTML = otherHtml;

            // Cross-risk-class correlation matrix (psi)
            let corrHtml = '<thead><tr><th></th>';
            SIMM_PARAMS.riskClasses.forEach(rc => {
                corrHtml += `<th>${rc.substring(0, 6)}</th>`;
            });
            corrHtml += '</tr></thead><tbody>';
            SIMM_PARAMS.riskClasses.forEach((rc, i) => {
                corrHtml += `<tr><th>${rc}</th>`;
                SIMM_PARAMS.psiMatrix[i].forEach((val, j) => {
                    const cls = i === j ? 'diag' : '';
                    corrHtml += `<td class="${cls}">${val.toFixed(2)}</td>`;
                });
                corrHtml += '</tr>';
            });
            corrHtml += '</tbody>';
            document.getElementById('correlationMatrix').innerHTML = corrHtml;

            // Show sample IR tenor correlations in console for verification
            console.log('ISDA SIMM v2.6 - Sample IR Correlations:');
            console.log('  (2W, 30Y) =', getIRCorrelation(0, 11).toFixed(3), '(short vs long)');
            console.log('  (5Y, 10Y) =', getIRCorrelation(7, 8).toFixed(3), '(adjacent tenors)');
            console.log('  (1Y, 2Y)  =', getIRCorrelation(4, 5).toFixed(3));
        }

        // Populate CRIF and calculation details
        const MAX_CRIF_TRADES_IN_DROPDOWN = 100;
        const MAX_CRIF_TABLE_ROWS = 500;

        function populateCRIFDetails(data) {
            if (!data.crif_data) {
                // Generate synthetic CRIF data for sample (limit for large datasets)
                data.crif_data = generateSyntheticCRIF(data);
            }

            // Populate trade filter dropdown (limit options for large datasets)
            const tradeFilter = document.getElementById('crifTradeFilter');
            const tradesToShow = data.trades.slice(0, MAX_CRIF_TRADES_IN_DROPDOWN);
            const hiddenTradeCount = data.trades.length - tradesToShow.length;

            tradeFilter.innerHTML = '<option value="all">All Trades</option>';
            if (hiddenTradeCount > 0) {
                tradeFilter.innerHTML += `<option disabled> First ${MAX_CRIF_TRADES_IN_DROPDOWN} of ${data.trades.length} </option>`;
            }
            tradesToShow.forEach(t => {
                tradeFilter.innerHTML += `<option value="${t.id}">${t.id}</option>`;
            });

            // Populate risk type filter
            const riskTypes = [...new Set(data.crif_data.map(r => r.riskType))];
            const riskFilter = document.getElementById('crifRiskFilter');
            riskFilter.innerHTML = '<option value="all">All Risk Types</option>';
            riskTypes.forEach(rt => {
                riskFilter.innerHTML += `<option value="${rt}">${rt}</option>`;
            });

            // Populate CRIF table
            updateCRIFTable(data.crif_data);

            // Populate risk breakdown by portfolio
            updateRiskBreakdown(data);

            // Populate calculation details
            updateCalcDetails(data);
        }

        // Generate synthetic CRIF data for sample data
        const MAX_CRIF_TRADES = 500; // Limit CRIF generation for very large datasets

        function generateSyntheticCRIF(data) {
            const crif = [];
            const riskTypes = ['Risk_IRCurve', 'Risk_FX', 'Risk_Equity', 'Risk_Inflation'];
            const currencies = ['USD', 'EUR', 'GBP'];

            // Limit trades for CRIF generation in large datasets
            const tradesToProcess = data.trades.length > MAX_CRIF_TRADES
                ? data.trades.slice(0, MAX_CRIF_TRADES)
                : data.trades;

            tradesToProcess.forEach(trade => {
                // Generate IR sensitivities
                const numIRSens = Math.floor(Math.random() * 6) + 3;
                for (let i = 0; i < numIRSens; i++) {
                    const tenorIdx = Math.floor(Math.random() * 12);
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.1;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_IRCurve',
                        qualifier: trade.currency,
                        bucket: tenorIdx + 1,
                        label1: SIMM_PARAMS.irTenors[tenorIdx],
                        tenorIdx: tenorIdx,  // Store for correlation lookup
                        amount: amount,
                        riskWeight: getIRRiskWeight(trade.currency, tenorIdx),  // Currency-specific
                        riskClass: 'Rates'
                    });
                }

                // Add FX sensitivity for FX trades
                if (trade.type.includes('FX') || trade.type.includes('XCCY')) {
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.2;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_FX',
                        qualifier: trade.currency + 'USD',
                        bucket: '',
                        label1: '',
                        amount: amount,
                        riskWeight: SIMM_PARAMS.otherWeights['FX'],
                        riskClass: 'FX'
                    });
                }

                // Add Equity sensitivity for equity trades
                if (trade.type.includes('Equity')) {
                    const amount = (Math.random() - 0.5) * trade.standalone_im * 0.15;
                    crif.push({
                        tradeId: trade.id,
                        riskType: 'Risk_Equity',
                        qualifier: 'Equity_' + Math.floor(Math.random() * 10),
                        bucket: Math.floor(Math.random() * 11) + 1,
                        label1: '',
                        amount: amount,
                        riskWeight: SIMM_PARAMS.otherWeights['Equity'],
                        riskClass: 'Equity'
                    });
                }
            });

            return crif;
        }

        // Update CRIF table with filtering and pagination
        function updateCRIFTable(crifData) {
            const tradeFilter = document.getElementById('crifTradeFilter').value;
            const riskFilter = document.getElementById('crifRiskFilter').value;

            let filtered = crifData;
            if (tradeFilter !== 'all') {
                filtered = filtered.filter(r => r.tradeId === tradeFilter);
            }
            if (riskFilter !== 'all') {
                filtered = filtered.filter(r => r.riskType === riskFilter);
            }

            const totalCount = filtered.length;
            const displayCount = Math.min(totalCount, MAX_CRIF_TABLE_ROWS);
            const hiddenCount = totalCount - displayCount;

            const tbody = document.getElementById('crifTableBody');
            let html = '';

            for (let i = 0; i < displayCount; i++) {
                const row = filtered[i];
                const amtClass = row.amount >= 0 ? 'positive' : 'negative';
                const weighted = row.amount * row.riskWeight;
                const wtdClass = weighted >= 0 ? 'positive' : 'negative';
                html += `
                    <tr>
                        <td>${row.tradeId}</td>
                        <td>${row.riskType}</td>
                        <td>${row.qualifier}</td>
                        <td>${row.bucket}</td>
                        <td>${row.label1}</td>
                        <td class="num ${amtClass}">${formatNumber(row.amount)}</td>
                        <td class="num">${row.riskWeight}</td>
                        <td class="num ${wtdClass}">${formatNumber(weighted)}</td>
                    </tr>
                `;
            }

            if (hiddenCount > 0) {
                html += `
                    <tr>
                        <td colspan="8" style="text-align:center; color:#4fc3f7; background: rgba(79, 195, 247, 0.1);">
                            Showing ${displayCount} of ${totalCount} rows. Use filters to narrow down.
                        </td>
                    </tr>
                `;
            }

            tbody.innerHTML = html || '<tr><td colspan="8" style="text-align:center;color:#666;">No data</td></tr>';
        }

        // Filter CRIF table
        function filterCRIF() {
            if (demoData && demoData.crif_data) {
                updateCRIFTable(demoData.crif_data);
            }
        }

        // Update risk breakdown by portfolio
        function updateRiskBreakdown(data) {
            const container = document.getElementById('riskTables');
            let html = '';

            // Pre-build trade ID to portfolio mapping for O(1) lookup
            const tradeToPortfolio = {};
            data.trades.forEach((t, i) => {
                tradeToPortfolio[t.id] = data.final_state.assignments[i];
            });

            // Pre-build CRIF by portfolio in O(C) instead of O(P * C)
            const crifByPortfolio = {};
            for (let p = 0; p < data.config.num_portfolios; p++) {
                crifByPortfolio[p] = [];
            }
            data.crif_data.forEach(row => {
                const p = tradeToPortfolio[row.tradeId];
                if (p !== undefined) {
                    crifByPortfolio[p].push(row);
                }
            });

            // Pre-count trades per portfolio
            const tradesPerPortfolio = new Array(data.config.num_portfolios).fill(0);
            data.final_state.assignments.forEach(p => tradesPerPortfolio[p]++);

            for (let p = 0; p < data.config.num_portfolios; p++) {
                const pCRIF = crifByPortfolio[p];
                const numTrades = tradesPerPortfolio[p];

                // Aggregate by risk class with weighted sensitivities
                const byRiskClass = {};
                SIMM_PARAMS.riskClasses.forEach(rc => byRiskClass[rc] = {
                    sensSum: 0,
                    wtdSensList: [],  // For correlation calculation
                    tenorIdxList: [], // For IR correlation lookup
                    count: 0
                });

                pCRIF.forEach(row => {
                    const rc = row.riskClass || 'Rates';
                    byRiskClass[rc].sensSum += row.amount;
                    byRiskClass[rc].wtdSensList.push(row.amount * row.riskWeight);
                    byRiskClass[rc].tenorIdxList.push(row.tenorIdx || 0);
                    byRiskClass[rc].count++;
                });

                // Calculate K values with ISDA correlations
                let totalK = 0;
                const kValues = {};
                SIMM_PARAMS.riskClasses.forEach(rc => {
                    const wsList = byRiskClass[rc].wtdSensList;
                    const tenorList = byRiskClass[rc].tenorIdxList;
                    const n = wsList.length;

                    if (n === 0) {
                        kValues[rc] = 0;
                        return;
                    }

                    // K = _i _j _ij  WS_i  WS_j
                    let kSquared = 0;
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            let rho;
                            if (rc === 'Rates') {
                                // IR: use tenor correlation matrix
                                rho = getIRCorrelation(tenorList[i], tenorList[j]);
                            } else {
                                // Other risk classes: intra-bucket correlation
                                rho = (i === j) ? 1.0 : (SIMM_PARAMS.intraCorrelations[rc] || 0.5);
                            }
                            kSquared += rho * wsList[i] * wsList[j];
                        }
                    }
                    kValues[rc] = Math.sqrt(Math.max(0, kSquared));
                    totalK += kValues[rc];
                });

                // Portfolio IM from data
                const pIM = data.final_state.portfolio_ims.find(x => x.portfolio === p)?.im || 0;

                html += `
                    <div class="risk-table-card">
                        <h5>Portfolio ${p + 1} (${numTrades} trades)</h5>
                        <table>
                            <thead>
                                <tr><th>Risk Class</th><th>Net Sens</th><th>K Value</th></tr>
                            </thead>
                            <tbody>
                `;

                SIMM_PARAMS.riskClasses.forEach(rc => {
                    if (byRiskClass[rc].count > 0 || kValues[rc] > 0) {
                        html += `
                            <tr>
                                <td>${rc}</td>
                                <td class="value">${formatNumber(byRiskClass[rc].sensSum)}</td>
                                <td class="value">${formatCurrency(kValues[rc])}</td>
                            </tr>
                        `;
                    }
                });

                html += `
                            <tr class="total-row">
                                <td>Total IM</td>
                                <td></td>
                                <td class="value">${formatCurrency(pIM)}</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Update calculation details
        function updateCalcDetails(data) {
            const container = document.getElementById('calcTables');
            let html = '';

            // Show before/after comparison
            html += `
                <div class="risk-table-card">
                    <h5>Initial Allocation</h5>
                    <table>
                        <thead><tr><th>Portfolio</th><th>Trades</th><th>IM</th></tr></thead>
                        <tbody>
            `;
            data.initial_state.portfolio_ims.forEach(p => {
                html += `<tr><td>Portfolio ${p.portfolio + 1}</td><td>${p.trades}</td><td class="value">${formatCurrency(p.im)}</td></tr>`;
            });
            html += `
                        <tr class="total-row"><td>Total</td><td>${data.config.num_trades}</td><td class="value">${formatCurrency(data.initial_state.total_im)}</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            html += `
                <div class="risk-table-card">
                    <h5>Final Allocation</h5>
                    <table>
                        <thead><tr><th>Portfolio</th><th>Trades</th><th>IM</th></tr></thead>
                        <tbody>
            `;
            data.final_state.portfolio_ims.forEach(p => {
                html += `<tr><td>Portfolio ${p.portfolio + 1}</td><td>${p.trades}</td><td class="value">${formatCurrency(p.im)}</td></tr>`;
            });
            html += `
                        <tr class="total-row"><td>Total</td><td>${data.config.num_trades}</td><td class="value">${formatCurrency(data.final_state.total_im)}</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            // Savings summary
            const savings = data.initial_state.total_im - data.final_state.total_im;
            html += `
                <div class="risk-table-card" style="background: rgba(102, 187, 106, 0.1);">
                    <h5 style="color: #66bb6a;">Optimization Savings</h5>
                    <table>
                        <tbody>
                            <tr><td>Initial IM</td><td class="value">${formatCurrency(data.initial_state.total_im)}</td></tr>
                            <tr><td>Final IM</td><td class="value">${formatCurrency(data.final_state.total_im)}</td></tr>
                            <tr class="total-row" style="color: #66bb6a;"><td>Savings</td><td class="value">${formatCurrency(savings)} (${formatPercent(data.optimization.im_reduction_pct)})</td></tr>
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = html;
        }

        // Format number with sign
        function formatNumber(value) {
            if (Math.abs(value) >= 1e9) {
                return (value >= 0 ? '+' : '') + (value / 1e9).toFixed(2) + 'B';
            } else if (Math.abs(value) >= 1e6) {
                return (value >= 0 ? '+' : '') + (value / 1e6).toFixed(2) + 'M';
            } else if (Math.abs(value) >= 1e3) {
                return (value >= 0 ? '+' : '') + (value / 1e3).toFixed(2) + 'K';
            }
            return (value >= 0 ? '+' : '') + value.toFixed(2);
        }

        // Initialize params on load
        initializeSIMMParams();

        // Load real data or fall back to manual mode
        window.addEventListener('load', async () => {
            try {
                const csvText = await loadCSV('execution_log_portfolio.csv');
                if (csvText) {
                    const rows = parseCSV(csvText);
                    allCsvRows = rows;
                    const configs = discoverConfigs(rows);
                    if (configs.length > 0) {
                        populateConfigSelector(configs);
                        await selectConfig(0);
                        return;
                    }
                }
            } catch(e) {
                console.log('No real data available:', e.message);
            }
            // No real data
            document.getElementById('configSelector').style.display = 'none';
        });
        // ===== Main Tab Switching =====
        const mainTabLoaded = { optimizer: true, newtrade: false, whatif: false, scaling: false };

        function switchMainTab(tabId, btn) {
            document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.main-tab-content').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById('tab-' + tabId).classList.add('active');

            if (!mainTabLoaded[tabId]) {
                mainTabLoaded[tabId] = true;
                if (tabId === 'newtrade') loadNewTradeTab();
                else if (tabId === 'whatif') loadWhatIfTab();
                else if (tabId === 'scaling') loadScalingTab();
            }
        }

        // ===== Helper: format currency for new tabs =====
        function fmtCur(n) {
            if (n == null) return 'N/A';
            const abs = Math.abs(n);
            const sign = n < 0 ? '-' : '';
            if (abs >= 1e12) return sign + '$' + (abs / 1e12).toFixed(2) + 'T';
            if (abs >= 1e9) return sign + '$' + (abs / 1e9).toFixed(2) + 'B';
            if (abs >= 1e6) return sign + '$' + (abs / 1e6).toFixed(2) + 'M';
            if (abs >= 1e3) return sign + '$' + (abs / 1e3).toFixed(1) + 'K';
            return sign + '$' + abs.toFixed(0);
        }
        function fmtPct(n) { return (n != null ? n.toFixed(1) : '0') + '%'; }

        // ===== New Trade Tab =====
        async function loadNewTradeTab() {
            const data = await loadJSON('pretrade.json');
            const loadingEl = document.getElementById('newtrade-loading');
            const contentEl = document.getElementById('newtrade-content');
            const errorEl = document.getElementById('newtrade-error');

            if (!data) {
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                return;
            }
            loadingEl.style.display = 'none';
            contentEl.style.display = 'block';
            renderNewTrade(data);
        }

        function renderNewTrade(data) {
            const trade = data.new_trade;
            const portfolio = data.portfolio || {};
            const marginal = data.marginal_im || {};
            const timing = marginal.timing || {};
            const aadcTiming = timing.aadc || {};
            const hasMarginal = marginal.im_before != null;
            const hasPortfolio = portfolio.num_trades != null;

            // Banner
            let bannerHtml = '';
            if (hasPortfolio) {
                bannerHtml += `
                    <div class="perf-card">
                        <div class="perf-value">${(portfolio.num_trades || 0).toLocaleString()}</div>
                        <div class="perf-label">Portfolio Trades</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-value">${portfolio.num_risk_factors || 0}</div>
                        <div class="perf-label">Risk Factors</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-value">${fmtCur(portfolio.current_im)}</div>
                        <div class="perf-label">Current IM</div>
                    </div>`;
            }
            bannerHtml += `
                <div class="perf-card">
                    <div class="perf-value" style="color:#ffa726;">${trade.type}</div>
                    <div class="perf-label">New Trade</div>
                    <div class="perf-detail">${fmtCur(trade.notional)} ${trade.currency} ${trade.maturity}Y</div>
                </div>
                <div class="perf-card">
                    <div class="perf-value" style="color:#ef5350;">${fmtCur(trade.standalone_im)}</div>
                    <div class="perf-label">Standalone IM</div>
                </div>
            `;
            document.getElementById('nt-banner').innerHTML = bannerHtml;

            // Marginal IM (only if data has marginal_im object)
            if (hasMarginal) {
                const speedup = timing.speedup || 'N/A';
                const baselineMs = timing.baseline_full_recalc_ms || 0;
                document.getElementById('nt-marginal').innerHTML = `
                    <h3 style="color:#4fc3f7;margin-bottom:15px;">Marginal IM Analysis</h3>
                    <div class="comparison-panels">
                        <div class="comparison-panel">
                            <h3 style="color:#ffa726;">Before</h3>
                            <div class="im-value-large" style="color:#e0e0e0;">${fmtCur(marginal.im_before)}</div>
                            <div style="color:#888;">Portfolio IM</div>
                        </div>
                        <div class="comparison-panel">
                            <h3 style="color:#66bb6a;">After Adding Trade</h3>
                            <div class="im-value-large" style="color:#66bb6a;">${fmtCur(marginal.im_after)}</div>
                            <div style="color:#888;">Marginal IM: ${fmtCur(marginal.marginal_im)}</div>
                        </div>
                    </div>
                    <div class="speedup-callout">
                        AADC computes marginal IM in <strong>${(aadcTiming.total_ms || 0).toFixed(1)} ms</strong>
                        vs baseline full recalculation in <strong>${baselineMs.toFixed(1)} ms</strong>
                        &mdash; <strong>${speedup}</strong> speedup
                    </div>
                    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;margin-bottom:20px;border-left:3px solid #4fc3f7;">
                        <h4 style="color:#4fc3f7;margin-bottom:8px;font-size:0.9em;">How It Works</h4>
                        <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                            <strong style="color:#e0e0e0;">AADC method:</strong> Records the full SIMM aggregation formula as an AADC kernel, then computes the gradient
                            dIM/dSensitivity for every risk factor via a single adjoint backward pass. Marginal IM for any new trade
                            is then a dot product: <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">marginal_IM = &Sigma; gradient[k] &times; new_trade_sensitivity[k]</code>
                        </p>
                        <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                            <strong style="color:#e0e0e0;">Baseline:</strong> Concatenates the new trade&rsquo;s CRIF sensitivities with the existing portfolio, re-aggregates by risk factor,
                            and runs full SIMM aggregation (intra-bucket correlations, inter-bucket, cross-risk-class) from scratch.
                        </p>
                        <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                            <strong style="color:#e0e0e0;">Why only ${speedup}?</strong> The AADC total includes <strong style="color:#ffa726;">kernel recording</strong> (${(aadcTiming.kernel_recording_ms || 0).toFixed(0)} ms),
                            a one-time cost. In production the kernel is recorded once and reused for many candidate trades.
                            The per-trade cost is gradient eval + dot product = <strong style="color:#66bb6a;">${((aadcTiming.gradient_eval_ms || 0) + (aadcTiming.marginal_im_ms || 0)).toFixed(1)} ms</strong>,
                            giving an amortized <strong style="color:#66bb6a;">${(baselineMs / Math.max((aadcTiming.gradient_eval_ms || 0) + (aadcTiming.marginal_im_ms || 0), 0.01)).toFixed(0)}x</strong> speedup.
                        </p>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                        <div>
                            <h4 style="color:#66bb6a;margin-bottom:10px;font-size:0.95em;">AADC Timing Breakdown</h4>
                            <table class="tab-data-table">
                                <tbody>
                                    <tr><td>Kernel Recording</td><td class="num" style="color:#4fc3f7;">${(aadcTiming.kernel_recording_ms || 0).toFixed(1)} ms</td></tr>
                                    <tr><td>Gradient Evaluation</td><td class="num" style="color:#4fc3f7;">${(aadcTiming.gradient_eval_ms || 0).toFixed(1)} ms</td></tr>
                                    <tr><td>Marginal IM (dot product)</td><td class="num" style="color:#4fc3f7;">${(aadcTiming.marginal_im_ms || 0).toFixed(2)} ms</td></tr>
                                    <tr style="font-weight:700;border-top:2px solid #4fc3f7;"><td>AADC Total</td><td class="num" style="color:#66bb6a;">${(aadcTiming.total_ms || 0).toFixed(1)} ms</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <div>
                            <h4 style="color:#ffa726;margin-bottom:10px;font-size:0.95em;">Baseline (Full Recalculation)</h4>
                            <table class="tab-data-table">
                                <tbody>
                                    <tr><td>Full SIMM Recalculation</td><td class="num" style="color:#ffa726;">${baselineMs.toFixed(1)} ms</td></tr>
                                    <tr><td colspan="2" style="color:#888;font-size:0.85em;padding-top:10px;">
                                        Concatenates new trade CRIF with existing portfolio, re-aggregates ${portfolio.num_risk_factors || 0} risk factors, and runs full SIMM from scratch.
                                    </td></tr>
                                </tbody>
                            </table>
                            <div style="margin-top:12px;text-align:center;padding:10px;background:rgba(102,187,106,0.08);border-radius:8px;border:1px solid rgba(102,187,106,0.2);">
                                <span style="font-size:1.4rem;font-weight:700;color:#66bb6a;">${speedup}</span>
                                <span style="color:#888;margin-left:6px;">faster</span>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                document.getElementById('nt-marginal').style.display = 'none';
            }

            // Counterparty Routing Table
            const routing = data.routing;
            const cpResults = routing.counterparty_results || [];
            const hasCpTiming = cpResults.length > 0 && cpResults[0].timing;
            const hasCpTrades = cpResults.length > 0 && cpResults[0].num_trades != null;
            let headerCols = '<th>Counterparty</th>';
            if (hasCpTrades) headerCols += '<th>Trades</th>';
            headerCols += '<th>Current IM</th><th>Marginal IM</th><th>New IM</th>';
            if (hasCpTiming) headerCols += '<th>AADC Time</th>';
            let tableHtml = `<table class="tab-data-table">
                <thead><tr>${headerCols}</tr></thead><tbody>`;
            for (const r of cpResults) {
                const isRec = r.counterparty === routing.recommended_counterparty;
                tableHtml += `<tr class="${isRec ? 'highlight-row' : ''}">
                    <td>${r.counterparty} ${isRec ? '<span class="badge-tag success">Best</span>' : ''}</td>`;
                if (hasCpTrades) tableHtml += `<td>${(r.num_trades || 0).toLocaleString()}</td>`;
                tableHtml += `<td class="num">${fmtCur(r.current_im)}</td>
                    <td class="num" style="color:${r.marginal_im < 0 ? '#66bb6a' : '#ef5350'};font-weight:600;">${fmtCur(r.marginal_im)}</td>
                    <td class="num">${fmtCur(r.new_im)}</td>`;
                if (hasCpTiming) {
                    const cpTiming = r.timing || {};
                    const cpTotal = (cpTiming.kernel_recording_ms || 0) + (cpTiming.gradient_eval_ms || 0) + (cpTiming.marginal_im_ms || 0);
                    tableHtml += `<td class="num" style="color:#888;">${cpTotal.toFixed(0)} ms</td>`;
                }
                tableHtml += '</tr>';
            }
            tableHtml += '</tbody></table>';
            if (routing.margin_savings) {
                tableHtml += `<p style="margin-top:12px;color:#66bb6a;font-weight:600;">Margin savings vs worst option: ${fmtCur(routing.margin_savings)}</p>`;
            }
            if (routing.computation_time_ms) {
                tableHtml += `<p style="margin-top:6px;color:#888;font-size:0.85em;">Total routing computation: ${routing.computation_time_ms.toFixed(0)} ms for ${cpResults.length} counterparties</p>`;
            }
            tableHtml += `<div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;margin-top:12px;border-left:3px solid #4fc3f7;">
                <p style="color:#aaa;font-size:0.82em;line-height:1.5;margin:0;">
                    <strong style="color:#4fc3f7;">How it works.</strong> Each counterparty&rsquo;s marginal IM is computed via AADC: a separate kernel is recorded per counterparty portfolio,
                    the adjoint gradient is evaluated, then marginal IM is obtained as a dot product of the gradient with the new trade&rsquo;s sensitivities.
                    Per-counterparty timing shows kernel recording + gradient eval + dot product.
                </p>
            </div>`;
            document.getElementById('nt-routing-table').innerHTML = tableHtml;

            // Bilateral vs Cleared
            const bvc = data.bilateral_vs_cleared;
            if (bvc) {
                const isClearBetter = bvc.recommendation === 'CLEAR';
                const isBilateralBetter = bvc.recommendation === 'BILATERAL';
                let badgeClass, badgeText;
                if (bvc.recommendation === 'CLEAR') { badgeClass = 'success'; badgeText = 'CLEAR'; }
                else if (bvc.recommendation === 'BILATERAL') { badgeClass = 'primary'; badgeText = 'BILATERAL'; }
                else { badgeClass = 'warning'; badgeText = 'INDIFFERENT'; }

                document.getElementById('nt-bilateral').innerHTML = `
                    <div style="text-align:center;margin-bottom:15px;">
                        <span class="badge-tag ${badgeClass}" style="font-size:1rem;padding:4px 16px;">
                            Recommendation: ${badgeText}
                        </span>
                    </div>
                    <div class="comparison-panels" style="grid-template-columns:1fr 1fr;">
                        <div class="comparison-panel ${isBilateralBetter ? 'recommended' : ''}">
                            <h4 style="color:#4fc3f7;">Bilateral (${bvc.bilateral_counterparty})</h4>
                            <div class="im-value-large" style="color:${isBilateralBetter ? '#66bb6a' : '#e0e0e0'};">${fmtCur(bvc.bilateral_marginal_im)}</div>
                            <div style="color:#888;">ISDA SIMM Marginal IM</div>
                        </div>
                        <div class="comparison-panel ${isClearBetter ? 'recommended' : ''}">
                            <h4 style="color:#4fc3f7;">Cleared (${bvc.clearing_venue})</h4>
                            <div class="im-value-large" style="color:${isClearBetter ? '#66bb6a' : '#e0e0e0'};">${fmtCur(bvc.cleared_marginal_im)}</div>
                            <div style="color:#888;">CCP Marginal IM</div>
                        </div>
                    </div>
                    <div class="rationale-box">${bvc.rationale}</div>
                    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;margin-top:12px;border-left:3px solid #4fc3f7;">
                        <p style="color:#aaa;font-size:0.82em;line-height:1.5;margin:0 0 6px 0;">
                            <strong style="color:#4fc3f7;">Bilateral (ISDA SIMM):</strong> Full SIMM recalculation &mdash; computes IM for the existing portfolio, then IM for portfolio + new trade,
                            difference = marginal IM. Uses the real SIMM engine with 10-day holding period, conservative correlations, and all risk classes.
                        </p>
                        <p style="color:#aaa;font-size:0.82em;line-height:1.5;margin:0;">
                            <strong style="color:#4fc3f7;">Cleared (CCP):</strong> Simplified SPAN-like model based on public CCP methodology.
                            Uses 5-day holding period, net/gross blended sensitivities (80/20), CCP-specific risk weights, and sqrt cross-risk aggregation.
                            CCP margin is typically lower due to shorter holding period, daily variation margin, and mutualized default fund.
                        </p>
                    </div>
                `;
            }
        }

        // ===== What-If Tab =====
        async function loadWhatIfTab() {
            const data = await loadJSON('whatif.json');
            const loadingEl = document.getElementById('whatif-loading');
            const contentEl = document.getElementById('whatif-content');
            const errorEl = document.getElementById('whatif-error');

            if (!data) {
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                return;
            }
            loadingEl.style.display = 'none';
            contentEl.style.display = 'block';
            renderWhatIfTab(data);
        }

        function renderWhatIfTab(data) {
            // Handle both data formats: local (portfolio, attribution.timing.aadc) and server (portfolio_summary, attribution.computation_time_ms)
            const portfolio = data.portfolio || data.portfolio_summary || {};
            const attr = data.attribution || {};
            const attrTiming = attr.timing || {};
            const aadcT = attrTiming.aadc || {};
            // Flat format: attr.computation_time_ms; nested format: aadcT.total_ms
            const aadcTotalMs = aadcT.total_ms || attr.computation_time_ms || 0;
            const baselineMs = attrTiming.baseline_leave_one_out_ms || attr.naive_time_estimate_ms || 0;
            const speedup = attrTiming.speedup || attr.speedup || 'N/A';
            const method = attr.computation_method || 'unknown';

            // Format timing strings (must be before use in summary)
            const baselineFmt = baselineMs >= 1000 ? (baselineMs / 1000).toFixed(1) + ' s' : baselineMs.toFixed(0) + ' ms';
            const aadcFmt = aadcTotalMs >= 1000 ? (aadcTotalMs / 1000).toFixed(1) + ' s' : aadcTotalMs.toFixed(0) + ' ms';

            // Summary banner
            document.getElementById('wi-summary').innerHTML = `
                <div class="perf-card">
                    <div class="perf-value">${fmtCur(portfolio.total_im)}</div>
                    <div class="perf-label">Total IM</div>
                </div>
                <div class="perf-card">
                    <div class="perf-value">${portfolio.num_trades || 0} / ${portfolio.num_risk_factors || 0}</div>
                    <div class="perf-label">Trades / Risk Factors</div>
                </div>
                <div class="perf-card">
                    <div class="perf-value" style="color:#66bb6a;">${aadcFmt}</div>
                    <div class="perf-label">AADC Attribution</div>
                </div>
                <div class="perf-card">
                    <div class="perf-value" style="color:#ef5350;">${baselineFmt}</div>
                    <div class="perf-label">Baseline (Leave-One-Out)</div>
                </div>
                <div class="perf-card">
                    <div class="perf-value" style="color:#66bb6a;">${speedup}${typeof speedup === 'number' ? 'x' : ''}</div>
                    <div class="perf-label">AADC Speedup</div>
                </div>
            `;

            // AADC Performance detail
            let perfHtml = `
                <h4 style="color:#66bb6a;margin-bottom:10px;">AADC Gradient-Based Attribution</h4>
                <p style="color:#aaa;margin-bottom:10px;">
                    Full margin attribution for <strong style="color:#e0e0e0;">${portfolio.num_trades || 0} trades</strong> computed in
                    <strong style="color:#66bb6a;">${aadcFmt}</strong> using AADC adjoint gradients,
                    vs <strong style="color:#ef5350;">${baselineFmt}</strong> for naive leave-one-out approach
                    &mdash; <strong style="color:#66bb6a;">${speedup}${typeof speedup === 'number' ? 'x' : ''}</strong> speedup.
                </p>`;
            if (aadcT.kernel_recording_ms != null) {
                perfHtml += `
                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:12px;">
                    <div style="text-align:center;">
                        <div style="color:#4fc3f7;font-weight:600;">${(aadcT.kernel_recording_ms || 0).toFixed(1)} ms</div>
                        <div style="color:#888;font-size:0.8em;">Kernel Recording</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="color:#4fc3f7;font-weight:600;">${(aadcT.gradient_eval_ms || 0).toFixed(1)} ms</div>
                        <div style="color:#888;font-size:0.8em;">Gradient Eval</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="color:#4fc3f7;font-weight:600;">${(aadcT.attribution_ms || 0).toFixed(1)} ms</div>
                        <div style="color:#888;font-size:0.8em;">Attribution</div>
                    </div>
                    <div style="text-align:center;">
                        <div style="color:#66bb6a;font-weight:700;">${aadcTotalMs.toFixed(0)} ms</div>
                        <div style="color:#888;font-size:0.8em;">Total</div>
                    </div>
                </div>`;
            }
            document.getElementById('wi-perf').innerHTML = perfHtml;

            // How It Works explanation
            document.getElementById('wi-explanation').innerHTML = `
                <h4 style="color:#4fc3f7;margin-bottom:8px;font-size:0.9em;">How It Works</h4>
                <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                    <strong style="color:#e0e0e0;">The problem:</strong> "Which trades consume the most margin?" The naive approach removes each trade one at a time
                    and recalculates full SIMM &mdash; <em>N</em> trades &times; O(SIMM) = O(N&sup2;). For ${portfolio.num_trades || 'N'} trades at ~100 ms each,
                    that would take <strong style="color:#ef5350;">${baselineFmt}</strong>.
                </p>
                <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                    <strong style="color:#e0e0e0;">AADC solution:</strong> Record the SIMM aggregation as an AADC kernel, then compute
                    <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">&part;IM/&part;Sensitivity[k]</code>
                    for all K risk factors in a single adjoint pass. Each trade's marginal contribution is then a dot product:
                    <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">contribution[t] = &Sigma;<sub>k</sub> gradient[k] &times; sensitivity[t,k]</code>
                    &mdash; O(N&times;K) total, computed in <strong style="color:#66bb6a;">${aadcFmt}</strong>.
                </p>
                <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                    <strong style="color:#e0e0e0;">Positive contribution</strong> means the trade adds to portfolio margin (its sensitivities align with the portfolio).
                    <strong style="color:#e0e0e0;">Negative contribution</strong> means the trade provides netting benefit &mdash; removing it would <em>increase</em> margin.
                </p>
            `;

            // IM Breakdown by Risk Class
            const imBreakdown = data.im_breakdown || {};
            const rcNames = Object.keys(imBreakdown);
            if (rcNames.length > 0) {
                const totalIM = portfolio.total_im || 0;
                let bkHtml = '<table class="tab-data-table"><thead><tr><th>Risk Class</th><th>Measures</th><th>IM</th><th>% of Total</th></tr></thead><tbody>';
                for (const rc of rcNames) {
                    const rcData = imBreakdown[rc];
                    const measures = Object.entries(rcData.measures || {}).map(([m, v]) => m).join(', ');
                    const pct = totalIM > 0 ? (rcData.total / totalIM * 100) : 0;
                    bkHtml += `<tr>
                        <td style="color:#4fc3f7;font-weight:600;">${rc}</td>
                        <td style="color:#aaa;">${measures}</td>
                        <td class="num">${fmtCur(rcData.total)}</td>
                        <td class="num">${pct.toFixed(1)}%</td>
                    </tr>`;
                }
                bkHtml += '</tbody></table>';
                document.getElementById('wi-breakdown').innerHTML = bkHtml;
                document.getElementById('wi-breakdown-section').style.display = '';
            } else {
                document.getElementById('wi-breakdown-section').style.display = 'none';
            }

            // Attribution tables (enhanced with trade details)
            const contributions = attr.trade_contributions || [];
            const consumers = contributions.filter(c => c.is_margin_additive === true || c.is_margin_additive === 'True').slice(0, 10);
            const reducers = contributions.filter(c => c.is_margin_additive === false || c.is_margin_additive === 'False').slice(0, 10);
            const hasDetails = contributions.length > 0 && contributions[0].trade_details;

            document.getElementById('wi-consumers').innerHTML = buildAttrTable(consumers, '#ef5350', hasDetails);
            document.getElementById('wi-reducers').innerHTML = buildAttrTable(reducers, '#66bb6a', hasDetails);

            // Counterparty Routing
            const cpRouting = data.counterparty_routing || [];
            if (cpRouting.length > 0) {
                let cpHtml = '<table class="tab-data-table"><thead><tr><th>Counterparty</th><th>Current IM</th><th>Marginal IM</th><th>New IM</th><th>Netting</th></tr></thead><tbody>';
                let bestCp = cpRouting[0];
                for (const cp of cpRouting) {
                    if (cp.marginal_im < bestCp.marginal_im) bestCp = cp;
                }
                for (const cp of cpRouting) {
                    const isBest = cp === bestCp;
                    const nettingBenefit = cp.marginal_im < 0;
                    cpHtml += `<tr class="${isBest ? 'highlight-row' : ''}">
                        <td>${cp.counterparty} ${isBest ? '<span class="badge-tag success">Best</span>' : ''}</td>
                        <td class="num">${fmtCur(cp.current_im)}</td>
                        <td class="num" style="color:${nettingBenefit ? '#66bb6a' : '#ef5350'};font-weight:600;">${fmtCur(cp.marginal_im)}</td>
                        <td class="num">${fmtCur(cp.new_im)}</td>
                        <td class="num" style="color:${nettingBenefit ? '#66bb6a' : '#ef5350'};">${nettingBenefit ? 'Yes' : 'No'}</td>
                    </tr>`;
                }
                cpHtml += '</tbody></table>';
                document.getElementById('wi-routing').innerHTML = cpHtml;
                document.getElementById('wi-routing-note').innerHTML = `
                    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;border-left:3px solid #4fc3f7;">
                        <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                            <strong style="color:#e0e0e0;">Counterparty Routing:</strong> Shows the marginal IM impact of placing this portfolio's trades at each counterparty.
                            A negative marginal IM means the counterparty's existing book provides netting benefit &mdash; adding these trades would <em>reduce</em> total margin at that counterparty.
                            Each counterparty's gradient is computed via its own AADC kernel; marginal IM is a dot product of that gradient with the portfolio's sensitivities.
                        </p>
                    </div>
                `;
                document.getElementById('wi-routing-section').style.display = '';
            } else {
                document.getElementById('wi-routing-section').style.display = 'none';
            }

            // IM Ladder (Margin Over Time)
            const imLadder = data.im_ladder || [];
            if (imLadder.length > 0) {
                const currentIM = portfolio.total_im || 0;
                let ladderHtml = '<table class="tab-data-table"><thead><tr><th>Horizon</th><th>IM</th><th>Change</th><th>Change %</th></tr></thead><tbody>';
                ladderHtml += `<tr style="font-weight:600;">
                    <td style="color:#4fc3f7;">Today</td>
                    <td class="num">${fmtCur(currentIM)}</td>
                    <td class="num" style="color:#888;">&mdash;</td>
                    <td class="num" style="color:#888;">&mdash;</td>
                </tr>`;
                for (const step of imLadder) {
                    const changeColor = step.im_change < 0 ? '#66bb6a' : (step.im_change > 0 ? '#ef5350' : '#888');
                    ladderHtml += `<tr>
                        <td style="color:#ab47bc;font-weight:500;">+${step.horizon}</td>
                        <td class="num">${fmtCur(step.im)}</td>
                        <td class="num" style="color:${changeColor};">${fmtCur(step.im_change)}</td>
                        <td class="num" style="color:${changeColor};">${fmtPct(step.im_change_pct)}</td>
                    </tr>`;
                }
                ladderHtml += '</tbody></table>';
                document.getElementById('wi-ladder').innerHTML = ladderHtml;
                document.getElementById('wi-ladder-note').innerHTML = `
                    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;border-left:3px solid #ab47bc;">
                        <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                            <strong style="color:#e0e0e0;">IM Ladder:</strong> Projects how portfolio margin evolves as trades age.
                            Each horizon ages all trades by reducing their remaining maturity, recomputes CRIF sensitivities
                            (via AADC for Greeks), and runs SIMM on the aged portfolio. Shorter-maturity trades have smaller DV01,
                            so IM typically decreases as the portfolio rolls down the curve.
                        </p>
                    </div>
                `;
                document.getElementById('wi-ladder-section').style.display = '';
            } else {
                document.getElementById('wi-ladder-section').style.display = 'none';
            }

            // Scenarios
            const scenarios = data.scenarios || {};
            const numTrades = portfolio.num_trades || 0;
            const numRF = portfolio.num_risk_factors || 0;

            let scenarioHtml = '';
            if (scenarios.unwind) {
                const s = scenarios.unwind;
                const tMs = s.computation_time_ms;
                const hasTiming = tMs != null;
                scenarioHtml += `<div class="scenario-card">
                    <h4>${s.scenario_name}</h4>
                    <p style="color:#aaa;font-size:0.85em;">${s.description}</p>
                    ${hasTiming ? `<p style="margin:8px 0;">Computed in <strong style="color:#66bb6a;">${tMs.toFixed(1)} ms</strong></p>` : ''}
                    <p>IM Change: <strong style="color:${s.im_change < 0 ? '#66bb6a' : '#ef5350'};">${fmtPct(s.im_change_pct)}</strong></p>
                    <p style="color:#888;font-size:0.8em;">Trades: ${(s.trades_affected || []).join(', ')}</p>
                </div>`;
            }
            if (scenarios.hedge) {
                const s = scenarios.hedge;
                const tMs = s.computation_time_ms;
                const hasTiming = tMs != null;
                scenarioHtml += `<div class="scenario-card">
                    <h4>${s.scenario_name}</h4>
                    <p style="color:#aaa;font-size:0.85em;">${s.description}</p>
                    ${hasTiming ? `<p style="margin:8px 0;">Computed in <strong style="color:#66bb6a;">${tMs.toFixed(1)} ms</strong></p>` : ''}
                    <p>IM Change: <strong style="color:${s.im_change < 0 ? '#66bb6a' : '#ef5350'};">${fmtPct(s.im_change_pct)}</strong></p>
                    <p style="color:#888;font-size:0.8em;">Trades: ${(s.trades_affected || []).join(', ')}</p>
                </div>`;
            }
            document.getElementById('wi-scenarios').innerHTML = scenarioHtml || '<p style="color:#888;">No scenario data available.</p>';

            // Stress scenarios
            const stressData = scenarios.stress || [];
            let stressHtml = '';
            for (const s of stressData) {
                const shocks = Object.entries(s.shock_factors || {}).map(([k, v]) => {
                    const label = k.replace('Risk_', '');
                    const pctChange = ((v - 1) * 100);
                    return `${label} ${pctChange >= 0 ? '+' : ''}${pctChange.toFixed(0)}%`;
                }).join(', ');
                const tMs = s.computation_time_ms;
                const hasTiming = tMs != null;
                stressHtml += `<div class="scenario-card">
                    <h4>${s.scenario_name}</h4>
                    <p style="color:#888;font-size:0.85em;">Shocks: ${shocks}</p>
                    ${hasTiming ? `<p style="margin:4px 0;">Computed in <strong style="color:#66bb6a;">${tMs.toFixed(1)} ms</strong></p>` : ''}
                    <p>IM Change: <strong style="color:${s.im_change > 0 ? '#ef5350' : '#66bb6a'};">${fmtPct(s.im_change_pct)}</strong></p>
                </div>`;
            }
            document.getElementById('wi-stress').innerHTML = stressHtml || '<p style="color:#888;">No stress data available.</p>';

            // Total scenario computation time
            let totalScenarioMs = 0;
            let scenarioCount = 0;
            for (const key of ['unwind', 'hedge']) {
                if (scenarios[key] && scenarios[key].computation_time_ms != null) {
                    totalScenarioMs += scenarios[key].computation_time_ms;
                    scenarioCount++;
                }
            }
            for (const s of stressData) {
                if (s.computation_time_ms != null) {
                    totalScenarioMs += s.computation_time_ms;
                    scenarioCount++;
                }
            }

            // Naive comparison: without AADC attribution, you'd need N leave-one-out recalcs
            // just to identify which trades to unwind. Each scenario itself is 1 SIMM call.
            const naiveIdentifyMs = numTrades * 100; // ~100ms per SIMM call
            const naiveIdentifyFmt = naiveIdentifyMs >= 1000 ? (naiveIdentifyMs / 1000).toFixed(1) + ' s' : naiveIdentifyMs + ' ms';

            // Methodology explanations
            document.getElementById('wi-methodology').innerHTML = `
                <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;border-left:3px solid #66bb6a;">
                    <h4 style="color:#66bb6a;margin-bottom:8px;font-size:0.9em;">Unwind & Hedge: Computation Cost</h4>
                    <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                        <strong style="color:#e0e0e0;">Step 1 &mdash; Identify targets (AADC):</strong> The gradient-based attribution (above) identifies
                        which trades to unwind or hedge in <strong style="color:#66bb6a;">${aadcFmt}</strong>.
                        Without AADC, identifying the top contributors requires N leave-one-out SIMM recalculations
                        &mdash; <strong style="color:#ef5350;">${naiveIdentifyFmt}</strong> for ${numTrades} trades.
                    </p>
                    <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                        <strong style="color:#e0e0e0;">Step 2 &mdash; Evaluate scenario:</strong> Once targets are identified, each scenario
                        (unwind N trades, add a hedge) requires a single SIMM recalculation on the modified CRIF
                        ${totalScenarioMs > 0 ? `&mdash; <strong style="color:#66bb6a;">${totalScenarioMs.toFixed(1)} ms</strong> for ${scenarioCount} scenarios total.` : '.'}
                        The expensive part is Step 1; Step 2 is always O(1) SIMM calls.
                    </p>
                </div>
                <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:15px;border-left:3px solid #ffa726;">
                    <h4 style="color:#ffa726;margin-bottom:8px;font-size:0.9em;">Stress Scenarios: Computation Cost</h4>
                    <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                        <strong style="color:#e0e0e0;">Per scenario:</strong> Each stress test applies multiplicative shocks to CRIF sensitivities
                        (e.g., Risk_IRCurve &times; 1.5), then runs a single SIMM aggregation on the shocked portfolio.
                        This is a pure CRIF mutation + 1 SIMM call &mdash; no AADC kernel needed, no gradient computation.
                    </p>
                    <p style="color:#aaa;font-size:0.85em;line-height:1.6;margin-bottom:8px;">
                        <strong style="color:#e0e0e0;">With AADC gradient:</strong> For small shocks, the IM change can be approximated instantly
                        via the existing gradient:
                        <code style="color:#4fc3f7;background:rgba(79,195,247,0.1);padding:2px 6px;border-radius:3px;">&Delta;IM &approx; &Sigma;<sub>k</sub> gradient[k] &times; (&epsilon;<sub>k</sub> &times; sensitivity[k])</code>
                        &mdash; a single dot product, sub-millisecond. The full recalculation shown here gives the exact non-linear result.
                    </p>
                    <p style="color:#aaa;font-size:0.85em;line-height:1.6;">
                        <strong style="color:#e0e0e0;">Scaling:</strong> Running ${stressData.length} stress scenarios requires ${stressData.length} SIMM calls
                        ${totalScenarioMs > 0 ? `(${stressData.map(s => s.computation_time_ms || 0).reduce((a,b) => a+b, 0).toFixed(1)} ms total)` : ''}
                        &mdash; each scenario is independent and can be parallelized.
                    </p>
                </div>
            `;
        }

        function buildAttrTable(items, color, showDetails) {
            if (!items.length) return '<p style="color:#888;padding:10px;">No data</p>';
            let headerCols = '<th>Trade ID</th>';
            if (showDetails) headerCols += '<th>Details</th>';
            headerCols += '<th>Contribution</th><th>% of Total</th>';
            if (showDetails) headerCols += '<th>$/M Notional</th>';
            headerCols += '<th>Net Sensitivity</th>';
            let html = `<table class="tab-data-table"><thead><tr>${headerCols}</tr></thead><tbody>`;
            for (const c of items) {
                const d = c.trade_details || {};
                const dirBadge = d.direction === 'receiver'
                    ? '<span style="color:#66bb6a;font-size:0.8em;">RCV</span>'
                    : (d.direction === 'payer' ? '<span style="color:#ef5350;font-size:0.8em;">PAY</span>' : '');
                html += `<tr>
                    <td style="color:#4fc3f7;">${c.trade_id}</td>`;
                if (showDetails) {
                    const notional = d.notional ? fmtCur(d.notional) : '';
                    const mat = d.maturity ? d.maturity + 'Y' : '';
                    html += `<td style="color:#aaa;font-size:0.85em;white-space:nowrap;">${dirBadge} ${d.currency || ''} ${mat} ${notional}</td>`;
                }
                html += `<td class="num" style="color:${color};font-weight:600;">${fmtCur(c.marginal_contribution)}</td>
                    <td class="num">${fmtPct(c.contribution_pct)}</td>`;
                if (showDetails) {
                    html += `<td class="num" style="color:#888;">${c.margin_per_million_notional != null ? fmtCur(c.margin_per_million_notional) : '&mdash;'}</td>`;
                }
                html += `<td class="num">${fmtCur(c.net_sensitivity)}</td>
                </tr>`;
            }
            html += '</tbody></table>';
            return html;
        }
        // ===== Scaling Benchmarks Tab =====
        async function loadBenchmarkJSON(filename) {
            for (const base of ['data/benchmark_results/', '../data/benchmark_results/']) {
                try {
                    const resp = await fetch(base + filename);
                    if (resp.ok) return await resp.json();
                } catch(e) {}
            }
            return null;
        }

        let scalingData = {};

        async function loadScalingTab() {
            const loadingEl = document.getElementById('scaling-loading');
            const contentEl = document.getElementById('scaling-content');
            const errorEl = document.getElementById('scaling-error');

            // Load all three benchmark files
            const [gradientData, pretradeData, whatifData] = await Promise.all([
                loadBenchmarkJSON('gradient_scaling_benchmark.json'),
                loadBenchmarkJSON('pretrade_scaling_benchmark.json'),
                loadBenchmarkJSON('whatif_scaling_benchmark.json'),
            ]);

            scalingData = { gradient: gradientData, pretrade: pretradeData, whatif: whatifData };

            const hasAny = gradientData || pretradeData || whatifData;
            if (!hasAny) {
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                return;
            }

            loadingEl.style.display = 'none';
            contentEl.style.display = 'block';

            // Render hero banner
            renderScalingHero(gradientData, pretradeData, whatifData);

            // Render initial sub-tab
            if (gradientData) renderGradientScaling(gradientData);
            if (pretradeData) renderPretradeScaling(pretradeData);
            if (whatifData) renderWhatifScaling(whatifData);
        }

        function switchScalingSubtab(panel, btn) {
            document.querySelectorAll('.scaling-subtab').forEach(t => {
                t.style.background = 'transparent';
                t.style.color = '#aaa';
                t.classList.remove('active');
            });
            btn.style.background = 'rgba(79,195,247,0.15)';
            btn.style.color = '#4fc3f7';
            btn.classList.add('active');
            document.querySelectorAll('.scaling-panel').forEach(p => p.style.display = 'none');
            document.getElementById('scaling-' + panel).style.display = 'block';
        }

        function fmtTime(ms) {
            if (ms == null) return 'N/A';
            if (ms >= 3600000) return (ms / 3600000).toFixed(1) + 'h';
            if (ms >= 60000) return (ms / 60000).toFixed(1) + 'min';
            if (ms >= 1000) return (ms / 1000).toFixed(1) + 's';
            return ms.toFixed(1) + 'ms';
        }

        function fmtNum(n) {
            if (n == null) return 'N/A';
            if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
            if (n >= 1e3) return (n / 1e3).toFixed(0) + 'K';
            return n.toFixed(0);
        }

        function renderScalingHero(gradientData, pretradeData, whatifData) {
            const hero = document.getElementById('scaling-hero');
            const cards = [];

            if (gradientData && gradientData.results) {
                const valid = gradientData.results.filter(r => !r.error);
                const maxT = valid.length ? Math.max(...valid.map(r => r.num_trades)) : 0;
                const maxSpeedup = valid.length ? Math.max(...valid.map(r => r.speedup || 0)) : 0;
                cards.push(`<div class="perf-card"><div class="perf-value fast">${fmtNum(maxT)}</div><div class="perf-label">Max Trades Tested</div></div>`);
                cards.push(`<div class="perf-card"><div class="perf-value accent">${fmtNum(maxSpeedup)}</div><div class="perf-label">Gradient Speedup</div></div>`);
            }
            if (pretradeData && pretradeData.results) {
                const valid = pretradeData.results.filter(r => !r.error);
                if (valid.length) {
                    const last = valid[valid.length - 1];
                    cards.push(`<div class="perf-card"><div class="perf-value">${fmtNum(last.queries_per_second_aadc)}/s</div><div class="perf-label">Pre-Trade Queries</div></div>`);
                }
            }
            if (whatifData && whatifData.results) {
                const valid = whatifData.results.filter(r => !r.error);
                if (valid.length) {
                    const maxSpeedup = Math.max(...valid.map(r => r.speedup || 0));
                    cards.push(`<div class="perf-card"><div class="perf-value fast">${fmtNum(maxSpeedup)}</div><div class="perf-label">Attribution Speedup</div></div>`);
                }
            }

            hero.innerHTML = cards.join('');
        }

        function makeScalingTable(headers, rows) {
            let html = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;font-size:0.9em;">';
            html += '<thead><tr>';
            headers.forEach(h => html += `<th style="text-align:right;padding:8px 12px;border-bottom:2px solid #444;color:#4fc3f7;white-space:nowrap;">${h}</th>`);
            html += '</tr></thead><tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach((cell, i) => {
                    const style = i === 0
                        ? 'text-align:left;padding:8px 12px;border-bottom:1px solid #333;color:#e0e0e0;'
                        : 'text-align:right;padding:8px 12px;border-bottom:1px solid #333;color:#ccc;';
                    html += `<td style="${style}">${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table></div>';
            return html;
        }

        function makeBarChart(items, maxVal) {
            let html = '<div style="display:flex;flex-direction:column;gap:8px;">';
            items.forEach(item => {
                const pct = Math.min(100, (item.value / maxVal) * 100);
                html += `<div style="display:flex;align-items:center;gap:12px;">
                    <div style="width:120px;text-align:right;font-size:0.85em;color:#aaa;white-space:nowrap;">${item.label}</div>
                    <div style="flex:1;background:rgba(255,255,255,0.05);border-radius:4px;height:24px;position:relative;">
                        <div style="width:${pct}%;height:100%;background:${item.color || 'linear-gradient(90deg,#4fc3f7,#2196f3)'};border-radius:4px;"></div>
                    </div>
                    <div style="width:100px;text-align:right;font-size:0.85em;color:#e0e0e0;font-weight:600;">${item.display}</div>
                </div>`;
            });
            html += '</div>';
            return html;
        }

        function renderGradientScaling(data) {
            const results = (data.results || []).filter(r => !r.error);
            if (!results.length) return;

            // Table
            const headers = ['Trades', 'Portfolios', 'K', 'AADC/iter', 'Bump/iter (est)', 'Speedup', '100 iters (AADC)'];
            const rows = results.map(r => [
                fmtNum(r.num_trades),
                r.num_portfolios,
                r.num_risk_factors,
                fmtTime(r.aadc_total_iter_ms),
                fmtTime(r.bump_revalue_estimate_ms),
                fmtNum(r.speedup) + '',
                fmtTime(r.aadc_100_iters_s * 1000),
            ]);
            document.getElementById('scaling-gradient-table').innerHTML = makeScalingTable(headers, rows);

            // Bar chart: speedup by trade count
            const maxSpeedup = Math.max(...results.map(r => r.speedup));
            const chartItems = results.map(r => ({
                label: fmtNum(r.num_trades) + ' trades',
                value: r.speedup,
                display: fmtNum(r.speedup) + ' faster',
                color: 'linear-gradient(90deg,#4fc3f7,#2196f3)',
            }));
            document.getElementById('scaling-gradient-chart').innerHTML =
                '<h4 style="color:#aaa;margin-bottom:10px;font-size:0.9em;">AADC Speedup vs Bump-and-Revalue</h4>' +
                makeBarChart(chartItems, maxSpeedup);

            // Extrapolation
            const last = results[results.length - 1];
            const aadcPerTrade = last.aadc_total_iter_ms / last.num_trades;
            const bumpPerTradePortfolio = last.bump_revalue_estimate_ms / (last.num_trades * last.num_portfolios);
            const T1M = 1000000;
            const aadc1M = aadcPerTrade * T1M;
            const bump1M = bumpPerTradePortfolio * T1M * 20;

            document.getElementById('scaling-gradient-extrapolation').innerHTML = `
                <h4 style="color:#4fc3f7;margin-bottom:12px;">Extrapolation to 1,000,000 Trades</h4>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;">
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">${fmtTime(aadc1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC per iteration</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#ef5350;">${fmtTime(bump1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">Bump-and-revalue per iteration</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#8b5cf6;">${fmtNum(bump1M / aadc1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">Estimated speedup</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">${fmtTime(aadc1M * 100)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC: 100 iterations</div>
                    </div>
                </div>
                <p style="color:#888;font-size:0.85em;margin-top:12px;text-align:center;">
                    At 1M trades, bump-and-revalue is <strong style="color:#ef5350;">computationally infeasible</strong>.
                    AADC makes portfolio optimization <strong style="color:#22c55e;">practical in production</strong>.
                </p>
            `;
        }

        function renderPretradeScaling(data) {
            const results = (data.results || []).filter(r => !r.error);
            if (!results.length) return;

            const headers = ['Trades', 'CPs', 'AADC/query', 'Naive/query', 'Speedup', 'Queries/s', 'Break-even'];
            const rows = results.map(r => [
                fmtNum(r.num_trades),
                r.num_counterparties,
                fmtTime(r.aadc_query_avg_ms),
                fmtTime(r.naive_query_avg_ms),
                fmtNum(r.speedup_per_query) + '',
                fmtNum(r.queries_per_second_aadc),
                r.break_even_queries + ' queries',
            ]);
            document.getElementById('scaling-pretrade-table').innerHTML = makeScalingTable(headers, rows);

            // Bar chart
            const maxQps = Math.max(...results.map(r => r.queries_per_second_aadc));
            const chartItems = results.map(r => ({
                label: fmtNum(r.num_trades) + ' trades',
                value: r.queries_per_second_aadc,
                display: fmtNum(r.queries_per_second_aadc) + '/s',
                color: 'linear-gradient(90deg,#66bb6a,#43a047)',
            }));
            document.getElementById('scaling-pretrade-chart').innerHTML =
                '<h4 style="color:#aaa;margin-bottom:10px;font-size:0.9em;">AADC Pre-Trade Queries per Second</h4>' +
                makeBarChart(chartItems, maxQps);

            // Extrapolation
            const last = results[results.length - 1];
            document.getElementById('scaling-pretrade-extrapolation').innerHTML = `
                <h4 style="color:#4fc3f7;margin-bottom:12px;">Extrapolation to 1,000,000 Trades</h4>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;">
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">~${last.aadc_query_avg_ms.toFixed(3)}ms</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC query (O(K), constant)</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#ef5350;">~${fmtTime(last.naive_query_avg_ms * 10)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">Naive query (scales with T)</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#8b5cf6;">~${fmtNum(last.queries_per_second_aadc)}/s</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC queries/second</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">Real-time</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC enables instant decisions</div>
                    </div>
                </div>
                <p style="color:#888;font-size:0.85em;margin-top:12px;text-align:center;">
                    AADC query time is <strong style="color:#22c55e;">O(K)  independent of portfolio size</strong>.
                    A trader gets instant marginal IM across all counterparties, even with 1M trades.
                </p>
            `;
        }

        function renderWhatifScaling(data) {
            const results = (data.results || []).filter(r => !r.error);
            if (!results.length) return;

            const headers = ['Trades', 'K', 'AADC Total', 'Naive Total', 'Speedup', 'Euler Error'];
            const rows = results.map(r => [
                fmtNum(r.num_trades),
                r.num_risk_factors,
                fmtTime(r.aadc_total_ms),
                fmtTime(r.naive_total_ms),
                fmtNum(r.speedup) + '',
                r.euler_error_pct.toFixed(2) + '%',
            ]);
            document.getElementById('scaling-whatif-table').innerHTML = makeScalingTable(headers, rows);

            // Bar chart
            const maxSpeedup = Math.max(...results.map(r => r.speedup));
            const chartItems = results.map(r => ({
                label: fmtNum(r.num_trades) + ' trades',
                value: r.speedup,
                display: fmtNum(r.speedup) + ' faster',
                color: 'linear-gradient(90deg,#ffa726,#f57c00)',
            }));
            document.getElementById('scaling-whatif-chart').innerHTML =
                '<h4 style="color:#aaa;margin-bottom:10px;font-size:0.9em;">AADC Attribution Speedup vs Leave-One-Out</h4>' +
                makeBarChart(chartItems, maxSpeedup);

            // Extrapolation
            const last = results[results.length - 1];
            const aadcGradMs = last.aadc_gradient_ms;
            const aadcAttribPerTrade = last.aadc_attribution_ms / last.num_trades;
            const naivePerTrade = last.naive_per_trade_ms;
            const T1M = 1000000;
            const aadc1M = aadcGradMs + aadcAttribPerTrade * T1M;
            const naive1M = naivePerTrade * T1M;

            document.getElementById('scaling-whatif-extrapolation').innerHTML = `
                <h4 style="color:#4fc3f7;margin-bottom:12px;">Extrapolation to 1,000,000 Trades</h4>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;">
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">${fmtTime(aadc1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC: Full attribution</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#ef5350;">${fmtTime(naive1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">Naive leave-one-out</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#8b5cf6;">${fmtNum(naive1M / aadc1M)}</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">Estimated speedup</div>
                    </div>
                    <div style="text-align:center;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;">
                        <div style="font-size:1.8em;font-weight:700;color:#22c55e;">Actionable</div>
                        <div style="font-size:0.8em;color:#aaa;margin-top:4px;">AADC: Real-time reports</div>
                    </div>
                </div>
                <p style="color:#888;font-size:0.85em;margin-top:12px;text-align:center;">
                    At 1M trades, naive attribution takes <strong style="color:#ef5350;">${fmtTime(naive1M)}</strong>.
                    AADC delivers the full report in <strong style="color:#22c55e;">${fmtTime(aadc1M)}</strong> 
                    the difference between a <strong>real-time decision tool</strong> and an <strong>overnight batch job</strong>.
                </p>
            `;
        }

    </script>
</body>
</html>
