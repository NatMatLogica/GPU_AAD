<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISDA SIMM with AADC</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-glow: rgba(37, 99, 235, 0.35);
            --accent: #8b5cf6;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --cyan: #06b6d4;
            --bg-dark: #0a0e1a;
            --bg-card: #131a2e;
            --bg-surface: #1a2340;
            --text-primary: #e8ecf4;
            --text-secondary: #7a8baa;
            --border: #243050;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ---- Particle canvas ---- */
        #particles {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0; opacity: 0.4;
        }

        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; position: relative; z-index: 1; }

        /* ---- Hero Header ---- */
        .hero {
            text-align: center;
            padding: 3rem 2rem 2rem;
            position: relative;
            margin-bottom: 2rem;
        }
        .hero::before {
            content: '';
            position: absolute;
            top: -100px; left: 50%; transform: translateX(-50%);
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--primary-glow) 0%, transparent 70%);
            pointer-events: none; z-index: -1;
        }
        .hero-badge {
            display: inline-block;
            padding: 0.35rem 1.2rem;
            background: rgba(37, 99, 235, 0.15);
            border: 1px solid rgba(37, 99, 235, 0.4);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--primary);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }
        h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #fff 0%, var(--primary) 50%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .hero-sub {
            color: var(--text-secondary);
            font-size: 1.15rem;
            max-width: 700px;
            margin: 0 auto 2rem;
        }
        .hero-sub strong { color: var(--text-primary); }

        /* ---- Animated Speedup Counters ---- */
        .speed-strip {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 2.5rem;
        }
        .speed-card {
            text-align: center;
            padding: 1.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            position: relative;
            overflow: hidden;
            transition: transform 0.3s, border-color 0.3s;
        }
        .speed-card:hover {
            transform: translateY(-4px);
            border-color: var(--primary);
        }
        .speed-card::after {
            content: '';
            position: absolute; bottom: 0; left: 0; right: 0; height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            opacity: 0; transition: opacity 0.3s;
        }
        .speed-card:hover::after { opacity: 1; }
        .speed-number {
            font-size: 2.4rem;
            font-weight: 800;
            color: var(--success);
            font-variant-numeric: tabular-nums;
        }
        .speed-number.cyan { color: var(--cyan); }
        .speed-number.accent { color: var(--accent); }
        .speed-label {
            font-size: 0.78rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-top: 0.25rem;
        }
        .speed-detail {
            font-size: 0.72rem;
            color: #4a5a78;
            margin-top: 0.35rem;
        }

        /* ---- Tab Navigation ---- */
        .main-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 2.5rem;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 4px;
            border: 1px solid var(--border);
        }
        .main-tab {
            flex: 1;
            padding: 0.85rem 1rem;
            background: transparent;
            border: none;
            border-radius: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.25s;
            position: relative;
        }
        .main-tab:hover { color: var(--text-primary); background: rgba(255,255,255,0.03); }
        .main-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.35);
        }
        .main-tab-content { display: none; }
        .main-tab-content.active { display: block; animation: fadeUp 0.4s ease-out; }
        @keyframes fadeUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }

        /* ---- Cards ---- */
        .card {
            background: var(--bg-card);
            border-radius: 14px;
            padding: 1.75rem;
            border: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }
        .card h2 {
            font-size: 1.2rem;
            margin-bottom: 1.25rem;
            color: var(--text-primary);
            display: flex; align-items: center; gap: 0.6rem;
        }
        .card h2 .icon {
            width: 28px; height: 28px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.85rem; flex-shrink: 0;
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(380px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem; }

        /* ---- Pipeline Animation ---- */
        .pipeline {
            display: flex;
            align-items: stretch;
            gap: 0;
            margin: 2rem 0;
            position: relative;
        }
        .pipe-stage {
            flex: 1;
            padding: 1.5rem 1.25rem;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            position: relative;
            text-align: center;
            transition: all 0.4s;
            opacity: 0.5;
        }
        .pipe-stage.active {
            opacity: 1;
            border-color: var(--primary);
            background: linear-gradient(180deg, rgba(37,99,235,0.08), var(--bg-surface));
        }
        .pipe-stage:first-child { border-radius: 14px 0 0 14px; }
        .pipe-stage:last-child { border-radius: 0 14px 14px 0; }
        .pipe-stage .stage-num {
            width: 32px; height: 32px;
            background: var(--primary);
            border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }
        .pipe-stage.active .stage-num {
            box-shadow: 0 0 20px var(--primary-glow);
            animation: pulse-glow 2s ease-in-out infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px var(--primary-glow); }
            50% { box-shadow: 0 0 25px var(--primary-glow), 0 0 50px rgba(37,99,235,0.15); }
        }
        .pipe-stage h3 { font-size: 0.95rem; margin-bottom: 0.5rem; }
        .pipe-stage p { font-size: 0.8rem; color: var(--text-secondary); }
        .pipe-stage .pipe-time {
            margin-top: 0.75rem;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--success);
        }
        .pipe-arrow {
            display: flex; align-items: center; justify-content: center;
            color: var(--primary); font-size: 1.4rem; font-weight: 700;
            width: 40px; flex-shrink: 0; z-index: 2;
            background: var(--bg-dark);
        }

        /* ---- Data flow animation ---- */
        .flow-line {
            position: absolute;
            top: 50%; left: 0; right: 0;
            height: 2px;
            background: var(--border);
            z-index: 0;
        }
        .flow-dot {
            position: absolute;
            top: 50%; transform: translateY(-50%);
            width: 8px; height: 8px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary);
            animation: flow-move 3s linear infinite;
        }
        @keyframes flow-move { from { left: -8px; } to { left: 100%; } }

        /* ---- Chart ---- */
        .chart-container { position: relative; height: 350px; }
        .chart-container.tall { height: 420px; }

        /* ---- Tables ---- */
        .data-table { width: 100%; border-collapse: collapse; font-size: 0.88rem; }
        .data-table th, .data-table td {
            padding: 0.7rem 0.9rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .data-table th {
            background: var(--bg-surface);
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            position: sticky; top: 0; z-index: 2;
        }
        .data-table tr { transition: background 0.15s; }
        .data-table tr:hover td { background: rgba(37, 99, 235, 0.04); }
        .data-table .num { text-align: right; font-variant-numeric: tabular-nums; }
        .data-table .fast { color: var(--success); font-weight: 600; }
        .data-table .slow { color: var(--danger); font-weight: 600; }

        /* ---- Badges ---- */
        .badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.03em;
        }
        .badge-gd { background: rgba(37,99,235,0.15); color: var(--primary); }
        .badge-adam { background: rgba(139,92,246,0.15); color: var(--accent); }
        .badge-bfgs { background: rgba(6,182,212,0.15); color: var(--cyan); }
        .badge-greedy { background: rgba(245,158,11,0.15); color: var(--warning); }
        .badge-success { background: rgba(34,197,94,0.15); color: var(--success); }
        .badge-error { background: rgba(239,68,68,0.15); color: var(--danger); }

        /* ---- Comparison bar ---- */
        .cmp-bar-wrap { margin: 0.5rem 0; }
        .cmp-bar-label {
            font-size: 0.78rem;
            color: var(--text-secondary);
            margin-bottom: 0.2rem;
            display: flex; justify-content: space-between;
        }
        .cmp-bar-track {
            height: 24px;
            background: var(--bg-surface);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        .cmp-bar-fill {
            height: 100%;
            border-radius: 6px;
            display: flex; align-items: center; justify-content: flex-end;
            padding: 0 8px;
            font-size: 0.72rem;
            font-weight: 700;
            color: white;
            transition: width 1.5s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .cmp-bar-fill.aadc { background: linear-gradient(90deg, var(--primary), var(--success)); }
        .cmp-bar-fill.baseline { background: linear-gradient(90deg, var(--danger), #b91c1c); }

        /* ---- Speedup pill ---- */
        .speedup-pill {
            display: inline-flex; align-items: center; gap: 0.4rem;
            padding: 0.5rem 1.2rem;
            background: linear-gradient(135deg, rgba(34,197,94,0.12), rgba(37,99,235,0.08));
            border: 1px solid rgba(34,197,94,0.3);
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--success);
        }
        .speedup-pill .x { font-size: 1.5rem; }

        /* ---- Formula box ---- */
        .formula-box {
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1.25rem;
            margin: 0.75rem 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .formula-box .main { font-size: 1rem; color: var(--primary); margin-bottom: 0.5rem; }
        .formula-box .note { color: var(--text-secondary); font-size: 0.82rem; line-height: 1.7; }
        .formula-box .note em { color: var(--success); font-style: normal; }

        /* ---- Filters ---- */
        .filters {
            display: flex; gap: 0.75rem; flex-wrap: wrap;
            margin-bottom: 1.25rem;
            align-items: center;
        }
        .filter-btn {
            padding: 0.4rem 1rem;
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.82rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .filter-btn:hover { border-color: var(--primary); color: var(--text-primary); }
        .filter-btn.active { background: var(--primary); border-color: var(--primary); color: white; }

        /* ---- Log scroll ---- */
        .log-scroll {
            max-height: 520px;
            overflow-y: auto;
            border-radius: 10px;
            border: 1px solid var(--border);
        }
        .log-scroll::-webkit-scrollbar { width: 6px; }
        .log-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

        /* ---- Footer ---- */
        footer {
            text-align: center;
            padding: 2.5rem 2rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem;
            font-size: 0.85rem;
        }
        footer a { color: var(--primary); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        /* ---- Loading ---- */
        .loading { text-align: center; padding: 3rem; color: var(--text-secondary); }
        .spinner {
            display: inline-block; width: 36px; height: 36px;
            border: 3px solid var(--border); border-top-color: var(--primary);
            border-radius: 50%; animation: spin 0.7s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ---- Responsive ---- */
        @media (max-width: 900px) {
            h1 { font-size: 2rem; }
            .pipeline { flex-direction: column; }
            .pipe-arrow { width: auto; height: 30px; transform: rotate(90deg); }
            .grid, .grid-3 { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <canvas id="particles"></canvas>
    <div class="container">

        <!-- ==================== HERO ==================== -->
        <div class="hero">
            <div class="hero-badge">MatLogica AADC Technology</div>
            <h1>ISDA SIMM with AADC</h1>
            <p class="hero-sub">
                <strong>Automatic Adjoint Differentiation</strong> computes exact gradients through
                the full SIMM aggregation in a <strong>single adjoint pass</strong> &mdash;
                replacing bump-and-revalue with performance that scales to 100K+ trade portfolios.
            </p>
        </div>

        <!-- ---- Headline Metrics from Benchmarks ---- -->
        <div class="speed-strip" id="heroMetrics">
            <div class="speed-card">
                <div class="speed-number" data-target="81511" data-suffix="x">0x</div>
                <div class="speed-label">Gradient Speedup</div>
                <div class="speed-detail">100K trades vs bump-and-revalue</div>
            </div>
            <div class="speed-card">
                <div class="speed-number cyan" data-target="164000" data-suffix=" q/s" data-format="comma">0</div>
                <div class="speed-label">Pre-Trade Queries</div>
                <div class="speed-detail">Marginal IM per second (AADC)</div>
            </div>
            <div class="speed-card">
                <div class="speed-number accent" data-target="15619" data-suffix="x">0x</div>
                <div class="speed-label">Attribution Speedup</div>
                <div class="speed-detail">100K-trade what-if analysis</div>
            </div>
            <div class="speed-card">
                <div class="speed-number" data-target="33" data-suffix="ms">0ms</div>
                <div class="speed-label">Per Iteration</div>
                <div class="speed-detail">Full gradient, 100K trades, 20 portfolios</div>
            </div>
        </div>

        <!-- ==================== TABS ==================== -->
        <div class="main-tabs">
            <button class="main-tab active" onclick="switchTab('methodology', this)">How AADC Works</button>
            <button class="main-tab" onclick="switchTab('scaling', this)">Scaling Benchmarks</button>
            <button class="main-tab" onclick="switchTab('optimizer', this)">Optimizer Comparison</button>
            <button class="main-tab" onclick="switchTab('execlog', this)">Execution Log</button>
        </div>

        <!-- ================================================================ -->
        <!-- TAB 1: How AADC Works                                            -->
        <!-- ================================================================ -->
        <div id="tab-methodology" class="main-tab-content active">

            <div class="card">
                <h2><span class="icon">1</span> The AADC Pipeline for SIMM</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    AADC records the SIMM aggregation as a computational graph once, then
                    evaluates it with different inputs in a single vectorized call &mdash;
                    producing both the result <em>and</em> exact gradients for all risk factors simultaneously.
                </p>

                <div class="pipeline" id="pipeline">
                    <div class="pipe-stage active" id="ps-1">
                        <div class="stage-num">1</div>
                        <h3>Record Kernel</h3>
                        <p>Trace the SIMM formula as idouble operations. K risk-factor inputs, one IM output.</p>
                        <div class="pipe-time" id="pt-1">~410ms</div>
                        <div style="font-size:0.7rem; color:var(--text-secondary); margin-top:0.25rem;">One-time cost</div>
                    </div>
                    <div class="pipe-arrow">&rarr;</div>
                    <div class="pipe-stage" id="ps-2">
                        <div class="stage-num">2</div>
                        <h3>Batch Evaluate</h3>
                        <p>Single aadc.evaluate() call computes IM + gradients for <strong>all P portfolios</strong> at once.</p>
                        <div class="pipe-time" id="pt-2">~6ms</div>
                        <div style="font-size:0.7rem; color:var(--text-secondary); margin-top:0.25rem;">Per iteration</div>
                    </div>
                    <div class="pipe-arrow">&rarr;</div>
                    <div class="pipe-stage" id="ps-3">
                        <div class="stage-num">3</div>
                        <h3>Chain Rule</h3>
                        <p>Gradient w.r.t. allocation: &part;IM/&part;x[t,p] = &Sigma;<sub>k</sub> (&part;IM<sub>p</sub>/&part;S<sub>k</sub>) &times; S[t,k]</p>
                        <div class="pipe-time" id="pt-3">~1ms</div>
                        <div style="font-size:0.7rem; color:var(--text-secondary); margin-top:0.25rem;">NumPy matmul</div>
                    </div>
                    <div class="pipe-arrow">&rarr;</div>
                    <div class="pipe-stage" id="ps-4">
                        <div class="stage-num">4</div>
                        <h3>Optimize</h3>
                        <p>Gradient descent, Adam, or BFGS with simplex projection + greedy local search.</p>
                        <div class="pipe-time" id="pt-4">N iters</div>
                        <div style="font-size:0.7rem; color:var(--text-secondary); margin-top:0.25rem;">Choice of method</div>
                    </div>
                </div>
            </div>

            <!-- Key insight cards -->
            <div class="grid">
                <div class="card">
                    <h2><span class="icon">K</span> Why K Inputs, Not T&times;P</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        The kernel takes <strong>K aggregated risk-factor sensitivities</strong> as inputs
                        (K&asymp;50), not T&times;P individual trade allocations (which could be 100K&times;20 = 2M).
                        Aggregation <code>S<sub>p</sub>[k] = &Sigma;<sub>t</sub> x[t,p] &times; S[t,k]</code>
                        happens in fast NumPy outside the kernel.
                    </p>
                    <div class="formula-box">
                        <div class="main">Kernel: K inputs &rarr; IM + dIM/dS<sub>k</sub></div>
                        <div class="note">
                            <em>K &asymp; 50</em> risk factors (constant, independent of portfolio size)<br>
                            <em>Tape size</em> stays small &rarr; fast replay + adjoint<br>
                            <em>Trade count T</em> only affects the numpy matmul, not the AADC kernel
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2><span class="icon">P</span> Single Evaluate for All Portfolios</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        Instead of calling <code>evaluate()</code> P times (once per portfolio),
                        AADC accepts <strong>arrays of length P</strong> for each input.
                        One dispatch computes all P portfolio IMs and gradients &mdash;
                        eliminating P-1 Python&harr;C++ round-trips.
                    </p>
                    <div class="formula-box">
                        <div class="main">1 call &times; P values = P&times; fewer dispatches</div>
                        <div class="note">
                            <em>P=1</em>: 1 dispatch &rarr; 1 IM, K gradients<br>
                            <em>P=20</em>: still 1 dispatch &rarr; 20 IMs, 20&times;K gradients<br>
                            <em>Speedup</em>: 10&ndash;200&times; vs calling evaluate() in a loop
                        </div>
                    </div>
                </div>
            </div>

            <!-- AADC vs Bump visual comparison -->
            <div class="card">
                <h2><span class="icon">vs</span> AADC Adjoint vs Bump-and-Revalue</h2>
                <div id="methodComparison"></div>
            </div>
        </div>

        <!-- ================================================================ -->
        <!-- TAB 2: Scaling Benchmarks                                        -->
        <!-- ================================================================ -->
        <div id="tab-scaling" class="main-tab-content">
            <div id="scaling-loading" class="loading">
                <div class="spinner"></div>
                <p>Loading benchmark data...</p>
            </div>
            <div id="scaling-content" style="display:none;">
                <!-- Sub-tabs -->
                <div style="display:flex; gap:0.5rem; margin-bottom:1.5rem; flex-wrap:wrap;">
                    <button class="filter-btn active" onclick="switchScalingSub('gradient', this)">Portfolio Optimization</button>
                    <button class="filter-btn" onclick="switchScalingSub('pretrade', this)">Pre-Trade Queries</button>
                    <button class="filter-btn" onclick="switchScalingSub('whatif', this)">Margin Attribution</button>
                </div>
                <div id="sp-gradient" class="sp-panel"></div>
                <div id="sp-pretrade" class="sp-panel" style="display:none;"></div>
                <div id="sp-whatif" class="sp-panel" style="display:none;"></div>
            </div>
            <div id="scaling-error" style="display:none;" class="loading">
                <p style="color: var(--danger);">No scaling data found. Run benchmark scripts to generate.</p>
            </div>
        </div>

        <!-- ================================================================ -->
        <!-- TAB 3: Optimizer Comparison                                      -->
        <!-- ================================================================ -->
        <div id="tab-optimizer" class="main-tab-content">
            <div id="opt-loading" class="loading">
                <div class="spinner"></div>
                <p>Loading execution log...</p>
            </div>
            <div id="opt-content" style="display:none;"></div>
        </div>

        <!-- ================================================================ -->
        <!-- TAB 4: Execution Log                                             -->
        <!-- ================================================================ -->
        <div id="tab-execlog" class="main-tab-content">
            <div id="log-loading" class="loading">
                <div class="spinner"></div>
                <p>Loading execution log...</p>
            </div>
            <div id="log-content" style="display:none;"></div>
        </div>

        <footer>
            ISDA SIMM v2.6 Implementation &mdash; Gradients by
            <a href="https://matlogica.com" target="_blank" rel="noopener">MatLogica AADC</a>
        </footer>
    </div>

<script>
// ====================================================================
// Particles background
// ====================================================================
(function initParticles() {
    const canvas = document.getElementById('particles');
    const ctx = canvas.getContext('2d');
    let W, H, particles = [];

    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    for (let i = 0; i < 60; i++) {
        particles.push({
            x: Math.random() * W,
            y: Math.random() * H,
            r: Math.random() * 1.5 + 0.5,
            dx: (Math.random() - 0.5) * 0.3,
            dy: (Math.random() - 0.5) * 0.3,
            alpha: Math.random() * 0.4 + 0.1,
        });
    }

    function draw() {
        ctx.clearRect(0, 0, W, H);
        for (const p of particles) {
            p.x += p.dx; p.y += p.dy;
            if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
            if (p.y < 0) p.y = H; if (p.y > H) p.y = 0;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(37, 99, 235, ${p.alpha})`;
            ctx.fill();
        }
        // Draw lines between nearby particles
        for (let i = 0; i < particles.length; i++) {
            for (let j = i + 1; j < particles.length; j++) {
                const dx = particles[i].x - particles[j].x;
                const dy = particles[i].y - particles[j].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 150) {
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[j].x, particles[j].y);
                    ctx.strokeStyle = `rgba(37, 99, 235, ${0.06 * (1 - dist/150)})`;
                    ctx.stroke();
                }
            }
        }
        requestAnimationFrame(draw);
    }
    draw();
})();

// ====================================================================
// Animated counter
// ====================================================================
function animateCounters() {
    document.querySelectorAll('.speed-number[data-target]').forEach(el => {
        const target = parseFloat(el.dataset.target);
        const suffix = el.dataset.suffix || '';
        const useComma = el.dataset.format === 'comma';
        const duration = 2000;
        const start = performance.now();

        function tick(now) {
            const elapsed = now - start;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic
            const current = Math.round(target * eased);
            el.textContent = (useComma ? current.toLocaleString() : current.toLocaleString()) + suffix;
            if (progress < 1) requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
    });
}

// ====================================================================
// Pipeline animation
// ====================================================================
function animatePipeline() {
    const stages = document.querySelectorAll('.pipe-stage');
    let idx = 0;
    function step() {
        stages.forEach((s, i) => s.classList.toggle('active', i <= idx));
        idx = (idx + 1) % stages.length;
    }
    setInterval(step, 2000);
}

// ====================================================================
// Data loading
// ====================================================================
const dataCache = {};

async function loadJSON(filename, subdir) {
    const key = (subdir || '') + filename;
    if (dataCache[key]) return dataCache[key];
    const dirs = subdir ? [subdir + '/'] : ['data/animation/', '../data/animation/'];
    for (const d of dirs) {
        try {
            const r = await fetch(d + filename);
            if (!r.ok) continue;
            const data = await r.json();
            dataCache[key] = data;
            return data;
        } catch(e) {}
    }
    return null;
}

async function loadBenchmark(filename) {
    const dirs = ['data/benchmark_results/', '../data/benchmark_results/'];
    for (const d of dirs) {
        try {
            const r = await fetch(d + filename);
            if (!r.ok) continue;
            return await r.json();
        } catch(e) {}
    }
    return null;
}

async function loadCSV(filename) {
    const dirs = ['data/', '../data/'];
    for (const d of dirs) {
        try {
            const r = await fetch(d + filename);
            if (!r.ok) continue;
            return await r.text();
        } catch(e) {}
    }
    return null;
}

function parseCSV(text) {
    if (!text) return [];
    const lines = text.trim().split('\n');
    if (lines.length < 2) return [];
    const headers = lines[0].split(',').map(h => h.trim());
    return lines.slice(1).map(line => {
        const vals = line.split(',');
        const obj = {};
        headers.forEach((h, i) => obj[h] = vals[i] ? vals[i].trim() : '');
        return obj;
    });
}

// ====================================================================
// Formatters
// ====================================================================
function fmtTime(ms) {
    if (ms == null || isNaN(ms)) return 'N/A';
    if (ms < 0.01) return (ms * 1000).toFixed(1) + 'us';
    if (ms < 1) return ms.toFixed(3) + 'ms';
    if (ms < 1000) return ms.toFixed(1) + 'ms';
    if (ms < 60000) return (ms / 1000).toFixed(1) + 's';
    return (ms / 60000).toFixed(1) + 'min';
}
function fmtSec(s) {
    if (s == null || isNaN(s)) return 'N/A';
    if (s < 0.001) return (s * 1e6).toFixed(0) + 'us';
    if (s < 1) return (s * 1000).toFixed(1) + 'ms';
    return s.toFixed(2) + 's';
}
function fmtNum(n) {
    if (n == null) return 'N/A';
    if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
    if (n >= 1e3) return (n / 1e3).toFixed(0) + 'K';
    return n.toFixed(0);
}
function fmtDollar(n) {
    if (n == null) return 'N/A';
    if (Math.abs(n) >= 1e12) return '$' + (n / 1e12).toFixed(1) + 'T';
    if (Math.abs(n) >= 1e9) return '$' + (n / 1e9).toFixed(1) + 'B';
    if (Math.abs(n) >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
    return '$' + n.toFixed(0);
}

// ====================================================================
// Tab switching
// ====================================================================
const tabLoaded = {};
function switchTab(id, btn) {
    document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.main-tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + id).classList.add('active');

    if (!tabLoaded[id]) {
        tabLoaded[id] = true;
        if (id === 'scaling') loadScalingTab();
        else if (id === 'optimizer') loadOptimizerTab();
        else if (id === 'execlog') loadExecLogTab();
    }
}

// ====================================================================
// Methodology tab - comparison bars
// ====================================================================
function renderMethodComparison() {
    const container = document.getElementById('methodComparison');
    const scenarios = [
        { label: '1K trades, 20 portfolios', aadc: 2.69, bump: 1961, unit: 'ms/iter' },
        { label: '10K trades, 20 portfolios', aadc: 6.64, bump: 38466, unit: 'ms/iter' },
        { label: '100K trades, 20 portfolios', aadc: 33.2, bump: 2705752, unit: 'ms/iter' },
    ];

    let html = '';
    for (const s of scenarios) {
        const speedup = Math.round(s.bump / s.aadc);
        const bumpPct = 100;
        const aadcPct = Math.max(1, (s.aadc / s.bump) * 100);

        html += `<div style="margin-bottom:1.5rem;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                <span style="font-weight:600;">${s.label}</span>
                <span class="speedup-pill"><span class="x">${speedup.toLocaleString()}</span>x faster</span>
            </div>
            <div class="cmp-bar-wrap">
                <div class="cmp-bar-label"><span>AADC (adjoint)</span><span style="color:var(--success)">${fmtTime(s.aadc)}</span></div>
                <div class="cmp-bar-track"><div class="cmp-bar-fill aadc" style="width:0%" data-w="${aadcPct}%">${fmtTime(s.aadc)}</div></div>
            </div>
            <div class="cmp-bar-wrap">
                <div class="cmp-bar-label"><span>Bump-and-revalue</span><span style="color:var(--danger)">${fmtTime(s.bump)}</span></div>
                <div class="cmp-bar-track"><div class="cmp-bar-fill baseline" style="width:0%" data-w="${bumpPct}%">${fmtTime(s.bump)}</div></div>
            </div>
        </div>`;
    }
    container.innerHTML = html;

    // Animate bars after a short delay
    setTimeout(() => {
        container.querySelectorAll('.cmp-bar-fill').forEach(el => {
            el.style.width = el.dataset.w;
        });
    }, 300);
}

// ====================================================================
// Scaling Tab
// ====================================================================
function switchScalingSub(panel, btn) {
    document.querySelectorAll('.sp-panel').forEach(p => p.style.display = 'none');
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('sp-' + panel).style.display = 'block';
    btn.classList.add('active');
}

function chartOpts(yLabel, logScale) {
    return {
        responsive: true, maintainAspectRatio: false,
        plugins: {
            legend: { labels: { color: '#7a8baa', font: { size: 12 } } },
            tooltip: {
                backgroundColor: '#1a2340',
                borderColor: '#243050',
                borderWidth: 1,
                titleColor: '#e8ecf4',
                bodyColor: '#7a8baa',
            }
        },
        scales: {
            x: { ticks: { color: '#7a8baa' }, grid: { color: 'rgba(36,48,80,0.5)' } },
            y: {
                type: logScale ? 'logarithmic' : 'linear',
                ticks: { color: '#7a8baa' },
                grid: { color: 'rgba(36,48,80,0.5)' },
                title: yLabel ? { display: true, text: yLabel, color: '#7a8baa' } : undefined
            }
        }
    };
}

function renderGradientScaling(data, container) {
    const results = (data.results || []).filter(r => !r.error);
    if (!results.length) { container.innerHTML = '<p style="color:var(--danger);">No data</p>'; return; }

    const cid = 'grad-chart-' + Date.now();
    const cid2 = 'grad-speedup-chart-' + Date.now();

    let html = `<div class="card">
        <h2><span class="icon">G</span> AADC Gradient vs Bump-and-Revalue per Iteration</h2>
        <p style="color:var(--text-secondary); margin-bottom:1.5rem;">
            Each optimization iteration needs the gradient of total IM w.r.t. the allocation matrix.
            AADC computes this via a single adjoint pass; bump-and-revalue requires T&times;P separate evaluations.
        </p>
        <div class="grid">
            <div>
                <div class="chart-container tall"><canvas id="${cid}"></canvas></div>
            </div>
            <div>
                <div class="chart-container tall"><canvas id="${cid2}"></canvas></div>
            </div>
        </div>
        <div style="overflow-x:auto;">
            <table class="data-table">
                <thead><tr>
                    <th>Trades</th><th>Portfolios</th><th>K (factors)</th>
                    <th class="num">AADC/iter</th><th class="num">Bump/iter</th><th class="num">Speedup</th>
                </tr></thead><tbody>`;
    for (const r of results) {
        html += `<tr>
            <td>${fmtNum(r.num_trades)}</td><td>${r.num_portfolios}</td><td>${r.num_risk_factors}</td>
            <td class="num fast">${fmtTime(r.aadc_total_iter_ms)}</td>
            <td class="num slow">${fmtTime(r.bump_revalue_estimate_ms)}</td>
            <td class="num" style="color:var(--accent); font-weight:700;">${Math.round(r.speedup).toLocaleString()}x</td>
        </tr>`;
    }
    html += '</tbody></table></div></div>';
    container.innerHTML = html;

    const labels = results.map(r => fmtNum(r.num_trades));
    new Chart(document.getElementById(cid), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                { label: 'AADC (ms)', data: results.map(r => r.aadc_total_iter_ms), backgroundColor: '#22c55e', borderRadius: 4 },
                { label: 'Bump-and-revalue (ms)', data: results.map(r => r.bump_revalue_estimate_ms), backgroundColor: '#ef4444', borderRadius: 4 },
            ]
        },
        options: chartOpts('Time per iteration (ms)', true)
    });
    new Chart(document.getElementById(cid2), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                label: 'Speedup (x)',
                data: results.map(r => r.speedup),
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139,92,246,0.1)',
                fill: true, tension: 0.3,
                pointRadius: 5, pointHoverRadius: 8,
                pointBackgroundColor: '#8b5cf6',
            }]
        },
        options: chartOpts('Speedup factor (x)', true)
    });
}

function renderPretradeScaling(data, container) {
    const results = (data.results || []).filter(r => !r.error);
    if (!results.length) { container.innerHTML = '<p style="color:var(--danger);">No data</p>'; return; }
    const cid = 'pt-chart-' + Date.now();

    let html = `<div class="card">
        <h2><span class="icon">Q</span> Pre-Trade Marginal IM Query Latency</h2>
        <p style="color:var(--text-secondary); margin-bottom:1.5rem;">
            AADC computes the gradient once, then answers any marginal-IM query with a single dot product.
            Each query costs ~6 microseconds regardless of portfolio size.
        </p>
        <div class="chart-container tall"><canvas id="${cid}"></canvas></div>
        <div style="overflow-x:auto; margin-top:1.5rem;">
            <table class="data-table">
                <thead><tr>
                    <th>Trades</th><th>Portfolios</th>
                    <th class="num">AADC/query</th><th class="num">Naive/query</th>
                    <th class="num">Speedup</th><th class="num">AADC queries/s</th>
                </tr></thead><tbody>`;
    for (const r of results) {
        html += `<tr>
            <td>${fmtNum(r.num_trades)}</td><td>${r.num_counterparties}</td>
            <td class="num fast">${fmtTime(r.aadc_query_avg_ms)}</td>
            <td class="num slow">${fmtTime(r.naive_query_avg_ms)}</td>
            <td class="num" style="color:var(--accent); font-weight:700;">${Math.round(r.speedup_per_query).toLocaleString()}x</td>
            <td class="num">${Math.round(r.queries_per_second_aadc).toLocaleString()}</td>
        </tr>`;
    }
    html += '</tbody></table></div></div>';
    container.innerHTML = html;

    new Chart(document.getElementById(cid), {
        type: 'bar',
        data: {
            labels: results.map(r => fmtNum(r.num_trades)),
            datasets: [
                { label: 'AADC (ms/query)', data: results.map(r => r.aadc_query_avg_ms), backgroundColor: '#22c55e', borderRadius: 4 },
                { label: 'Naive (ms/query)', data: results.map(r => r.naive_query_avg_ms), backgroundColor: '#ef4444', borderRadius: 4 },
            ]
        },
        options: chartOpts('Time per query (ms)', true)
    });
}

function renderWhatifScaling(data, container) {
    const results = (data.results || []).filter(r => !r.error);
    if (!results.length) { container.innerHTML = '<p style="color:var(--danger);">No data</p>'; return; }
    const cid = 'wi-chart-' + Date.now();

    let html = `<div class="card">
        <h2><span class="icon">A</span> Margin Attribution: AADC vs Leave-One-Out</h2>
        <p style="color:var(--text-secondary); margin-bottom:1.5rem;">
            AADC gradient gives exact per-trade Euler decomposition in one pass.
            Leave-one-out must remove each trade and re-evaluate SIMM, scaling O(N<sup>2</sup>).
            Numerical accuracy: Euler error &lt; 10<sup>-11</sup>.
        </p>
        <div class="chart-container tall"><canvas id="${cid}"></canvas></div>
        <div style="overflow-x:auto; margin-top:1.5rem;">
            <table class="data-table">
                <thead><tr>
                    <th>Trades</th>
                    <th class="num">AADC</th><th class="num">Leave-one-out</th>
                    <th class="num">Speedup</th><th class="num">Euler error</th>
                </tr></thead><tbody>`;
    for (const r of results) {
        html += `<tr>
            <td>${fmtNum(r.num_trades)}</td>
            <td class="num fast">${fmtTime(r.aadc_total_ms || r.aadc_attribution_ms)}</td>
            <td class="num slow">${fmtTime(r.naive_total_ms || r.naive_attribution_ms)}</td>
            <td class="num" style="color:var(--accent); font-weight:700;">${Math.round(r.speedup).toLocaleString()}x</td>
            <td class="num" style="color:var(--text-secondary);">${r.euler_error_pct ? r.euler_error_pct.toExponential(1) : 'N/A'}</td>
        </tr>`;
    }
    html += '</tbody></table></div></div>';
    container.innerHTML = html;

    new Chart(document.getElementById(cid), {
        type: 'bar',
        data: {
            labels: results.map(r => fmtNum(r.num_trades)),
            datasets: [
                { label: 'AADC (ms)', data: results.map(r => r.aadc_total_ms || r.aadc_attribution_ms), backgroundColor: '#22c55e', borderRadius: 4 },
                { label: 'Leave-one-out (ms)', data: results.map(r => r.naive_total_ms || r.naive_attribution_ms), backgroundColor: '#ef4444', borderRadius: 4 },
            ]
        },
        options: chartOpts('Attribution time (ms)', true)
    });
}

async function loadScalingTab() {
    const [gradData, pretradeData, whatifData] = await Promise.all([
        loadBenchmark('gradient_scaling_benchmark.json'),
        loadBenchmark('pretrade_scaling_benchmark.json'),
        loadBenchmark('whatif_scaling_benchmark.json'),
    ]);
    const any = gradData || pretradeData || whatifData;
    document.getElementById('scaling-loading').style.display = 'none';
    if (!any) { document.getElementById('scaling-error').style.display = 'block'; return; }
    document.getElementById('scaling-content').style.display = 'block';

    if (gradData) renderGradientScaling(gradData, document.getElementById('sp-gradient'));
    if (pretradeData) renderPretradeScaling(pretradeData, document.getElementById('sp-pretrade'));
    if (whatifData) renderWhatifScaling(whatifData, document.getElementById('sp-whatif'));
}

// ====================================================================
// Optimizer Comparison Tab
// ====================================================================
async function loadOptimizerTab() {
    const csvText = await loadCSV('execution_log_portfolio.csv');
    const loading = document.getElementById('opt-loading');
    const content = document.getElementById('opt-content');
    loading.style.display = 'none';

    if (!csvText) {
        content.innerHTML = '<p style="color:var(--danger); text-align:center; padding:3rem;">No execution log found.</p>';
        content.style.display = 'block';
        return;
    }

    const rows = parseCSV(csvText).filter(r => r.group_id === 'ALL' && r.optimize_method);
    content.style.display = 'block';

    // Group by (num_trades, num_portfolios, trade_types) for comparison
    const groups = {};
    for (const r of rows) {
        const key = `${r.num_trades}_${r.num_portfolios}_${r.trade_types}`;
        if (!groups[key]) groups[key] = { trades: +r.num_trades, portfolios: +r.num_portfolios, types: r.trade_types, runs: {} };
        const method = r.optimize_method;
        // Keep best run per method (lowest final IM)
        if (!groups[key].runs[method] || +r.optimize_final_im < +groups[key].runs[method].optimize_final_im) {
            groups[key].runs[method] = r;
        }
    }

    // Sort groups by trade count
    const sorted = Object.values(groups).sort((a, b) => a.trades - b.trades);

    // Find groups that have multiple methods
    const multiMethod = sorted.filter(g => Object.keys(g.runs).length > 1);
    const singleMethod = sorted.filter(g => Object.keys(g.runs).length === 1);

    let html = '';

    if (multiMethod.length > 0) {
        html += `<div class="card">
            <h2><span class="icon">M</span> Method Comparison (same configuration)</h2>
            <p style="color:var(--text-secondary); margin-bottom:1.5rem;">
                Side-by-side comparison of gradient descent, Adam, and BFGS on identical portfolios.
                All methods use the same AADC kernel &mdash; only the step direction differs.
            </p>`;

        for (const g of multiMethod) {
            const methods = Object.keys(g.runs).sort();
            html += `<div style="margin-bottom:2rem; padding:1.25rem; background:var(--bg-surface); border-radius:10px; border:1px solid var(--border);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem; flex-wrap:wrap; gap:0.5rem;">
                    <span style="font-weight:700; font-size:1.05rem;">${g.trades} trades, ${g.portfolios} portfolios</span>
                    <span style="color:var(--text-secondary); font-size:0.85rem;">${g.types}</span>
                </div>
                <div style="overflow-x:auto;">
                <table class="data-table">
                    <thead><tr>
                        <th>Method</th><th class="num">Initial IM</th><th class="num">Final IM</th>
                        <th class="num">Reduction</th><th class="num">Trades Moved</th>
                        <th class="num">Iterations</th><th class="num">Opt Time</th><th>Converged</th>
                    </tr></thead><tbody>`;

            // Find best final IM across methods for highlighting
            let bestIm = Infinity;
            for (const m of methods) bestIm = Math.min(bestIm, +g.runs[m].optimize_final_im);

            for (const m of methods) {
                const r = g.runs[m];
                const isBest = Math.abs(+r.optimize_final_im - bestIm) < 1;
                const badgeCls = m === 'adam' ? 'badge-adam' : m === 'bfgs' ? 'badge-bfgs' : m === 'gradient_descent' ? 'badge-gd' : 'badge-greedy';
                html += `<tr${isBest ? ' style="background:rgba(34,197,94,0.05)"' : ''}>
                    <td><span class="badge ${badgeCls}">${m}</span></td>
                    <td class="num">${fmtDollar(+r.optimize_initial_im)}</td>
                    <td class="num" style="font-weight:600; ${isBest ? 'color:var(--success)' : ''}">${fmtDollar(+r.optimize_final_im)}</td>
                    <td class="num">${(+r.optimize_im_reduction_pct).toFixed(1)}%</td>
                    <td class="num">${Math.round(+r.optimize_trades_moved)}</td>
                    <td class="num">${Math.round(+r.optimize_iterations)}</td>
                    <td class="num">${fmtSec(+r.optimize_time_sec)}</td>
                    <td>${r.optimize_converged === 'True' ? '<span class="badge badge-success">Yes</span>' : '<span style="color:var(--text-secondary)">No</span>'}</td>
                </tr>`;
            }
            html += '</tbody></table></div></div>';
        }
        html += '</div>';
    }

    // Chart: optimization time by method across scales
    const cid = 'opt-time-chart-' + Date.now();
    if (sorted.length > 1) {
        html += `<div class="card">
            <h2><span class="icon">T</span> Optimization Time vs Portfolio Size</h2>
            <div class="chart-container tall"><canvas id="${cid}"></canvas></div>
        </div>`;
    }

    // All runs table
    html += `<div class="card">
        <h2><span class="icon">L</span> All Optimization Runs</h2>
        <div style="overflow-x:auto;">
        <table class="data-table">
            <thead><tr>
                <th>Trades</th><th>P</th><th>Method</th>
                <th class="num">IM Reduction</th><th class="num">Moved</th>
                <th class="num">Iters</th><th class="num">Opt Time</th>
                <th class="num">CRIF Time</th><th class="num">Grad Time</th>
            </tr></thead><tbody>`;
    for (const r of rows) {
        const badgeCls = r.optimize_method === 'adam' ? 'badge-adam' : r.optimize_method === 'bfgs' ? 'badge-bfgs' : r.optimize_method === 'gradient_descent' ? 'badge-gd' : 'badge-greedy';
        html += `<tr>
            <td>${(+r.num_trades).toLocaleString()}</td><td>${r.num_portfolios}</td>
            <td><span class="badge ${badgeCls}">${r.optimize_method}</span></td>
            <td class="num" style="color:var(--success)">${(+r.optimize_im_reduction_pct).toFixed(1)}%</td>
            <td class="num">${Math.round(+r.optimize_trades_moved)}</td>
            <td class="num">${Math.round(+r.optimize_iterations)}</td>
            <td class="num">${fmtSec(+r.optimize_time_sec)}</td>
            <td class="num">${fmtSec(+r.crif_time_sec)}</td>
            <td class="num">${fmtSec(+r.im_sens_time_sec)}</td>
        </tr>`;
    }
    html += '</tbody></table></div></div>';
    content.innerHTML = html;

    // Render chart
    if (sorted.length > 1 && document.getElementById(cid)) {
        const allMethods = [...new Set(rows.map(r => r.optimize_method))].sort();
        const methodColors = { gradient_descent: '#2563eb', adam: '#8b5cf6', bfgs: '#06b6d4', greedy: '#f59e0b' };
        const datasets = allMethods.map(m => ({
            label: m,
            data: rows.filter(r => r.optimize_method === m).map(r => ({ x: +r.num_trades, y: +r.optimize_time_sec })),
            backgroundColor: methodColors[m] || '#94a3b8',
            borderColor: methodColors[m] || '#94a3b8',
            pointRadius: 6,
            pointHoverRadius: 9,
            showLine: false,
        }));
        new Chart(document.getElementById(cid), {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { labels: { color: '#7a8baa' } } },
                scales: {
                    x: { type: 'logarithmic', ticks: { color: '#7a8baa' }, grid: { color: 'rgba(36,48,80,0.5)' }, title: { display: true, text: 'Number of trades', color: '#7a8baa' } },
                    y: { type: 'logarithmic', ticks: { color: '#7a8baa' }, grid: { color: 'rgba(36,48,80,0.5)' }, title: { display: true, text: 'Optimization time (s)', color: '#7a8baa' } },
                }
            }
        });
    }
}

// ====================================================================
// Execution Log Tab
// ====================================================================
async function loadExecLogTab() {
    const csvText = await loadCSV('execution_log_portfolio.csv');
    const loading = document.getElementById('log-loading');
    const content = document.getElementById('log-content');
    loading.style.display = 'none';

    if (!csvText) {
        content.innerHTML = '<p style="color:var(--danger); text-align:center; padding:3rem;">No execution log found.</p>';
        content.style.display = 'block';
        return;
    }

    const allRows = parseCSV(csvText);
    const aggRows = allRows.filter(r => r.group_id === 'ALL');
    const groupRows = allRows.filter(r => r.group_id !== 'ALL');

    content.style.display = 'block';

    // Summary stats
    const totalRuns = aggRows.length;
    const methods = [...new Set(aggRows.map(r => r.optimize_method).filter(Boolean))];
    const maxTrades = Math.max(...aggRows.map(r => +r.num_trades));
    const totalOptTime = aggRows.reduce((s, r) => s + (+r.optimize_time_sec || 0), 0);

    let html = `
    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(160px, 1fr)); gap:1rem; margin-bottom:1.5rem;">
        <div class="speed-card" style="padding:1rem;">
            <div class="speed-number" style="font-size:1.8rem;">${totalRuns}</div>
            <div class="speed-label">Total Runs</div>
        </div>
        <div class="speed-card" style="padding:1rem;">
            <div class="speed-number cyan" style="font-size:1.8rem;">${fmtNum(maxTrades)}</div>
            <div class="speed-label">Max Trades</div>
        </div>
        <div class="speed-card" style="padding:1rem;">
            <div class="speed-number accent" style="font-size:1.8rem;">${methods.length}</div>
            <div class="speed-label">Methods Tested</div>
        </div>
        <div class="speed-card" style="padding:1rem;">
            <div class="speed-number" style="font-size:1.8rem;">${fmtSec(totalOptTime)}</div>
            <div class="speed-label">Total Opt Time</div>
        </div>
    </div>`;

    // Timing breakdown chart
    const cid = 'timing-breakdown-' + Date.now();
    html += `<div class="card">
        <h2><span class="icon">B</span> Timing Breakdown by Portfolio Size</h2>
        <p style="color:var(--text-secondary); margin-bottom:1rem;">
            How time is spent across the pipeline: CRIF precomputation (AADC adjoint pricing),
            SIMM aggregation, gradient computation (single adjoint pass), and optimizer iterations.
        </p>
        <div class="chart-container tall"><canvas id="${cid}"></canvas></div>
    </div>`;

    // Full log table
    html += `<div class="card">
        <h2><span class="icon">R</span> Run History</h2>
        <div class="log-scroll">
        <table class="data-table">
            <thead><tr>
                <th>Timestamp</th><th>Trades</th><th>P</th><th>Types</th>
                <th>Method</th>
                <th class="num">CRIF</th><th class="num">SIMM</th><th class="num">Gradient</th><th class="num">Optimize</th>
                <th class="num">IM Reduction</th><th>Status</th>
            </tr></thead><tbody>`;

    for (const r of aggRows) {
        const ts = r.timestamp ? r.timestamp.substring(5, 16).replace('T', ' ') : '';
        const method = r.optimize_method || '-';
        const badgeCls = method === 'adam' ? 'badge-adam' : method === 'bfgs' ? 'badge-bfgs' : method === 'gradient_descent' ? 'badge-gd' : method === 'greedy' ? 'badge-greedy' : '';
        const reduction = r.optimize_im_reduction_pct ? (+r.optimize_im_reduction_pct).toFixed(1) + '%' : '-';

        html += `<tr>
            <td style="font-size:0.8rem; color:var(--text-secondary); white-space:nowrap;">${ts}</td>
            <td>${(+r.num_trades).toLocaleString()}</td>
            <td>${r.num_portfolios}</td>
            <td style="font-size:0.78rem; max-width:160px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${r.trade_types}</td>
            <td>${badgeCls ? '<span class="badge ' + badgeCls + '">' + method + '</span>' : method}</td>
            <td class="num">${fmtSec(+r.crif_time_sec)}</td>
            <td class="num">${fmtSec(+r.simm_time_sec)}</td>
            <td class="num">${fmtSec(+r.im_sens_time_sec)}</td>
            <td class="num">${r.optimize_time_sec ? fmtSec(+r.optimize_time_sec) : '-'}</td>
            <td class="num" style="${reduction !== '-' ? 'color:var(--success)' : ''}">${reduction}</td>
            <td><span class="badge badge-success">${r.status}</span></td>
        </tr>`;
    }
    html += '</tbody></table></div></div>';
    content.innerHTML = html;

    // Timing breakdown stacked bar chart
    if (document.getElementById(cid)) {
        // Only use optimization runs, sorted by trades
        const optRuns = aggRows.filter(r => r.optimize_method).sort((a, b) => +a.num_trades - +b.num_trades);
        if (optRuns.length > 0) {
            // Deduplicate: keep latest per (trades, portfolios, method)
            const seen = {};
            const deduped = [];
            for (const r of optRuns) {
                const key = `${r.num_trades}_${r.num_portfolios}_${r.optimize_method}`;
                seen[key] = r;
            }
            for (const r of Object.values(seen)) deduped.push(r);
            deduped.sort((a, b) => +a.num_trades - +b.num_trades || a.optimize_method.localeCompare(b.optimize_method));

            const labels = deduped.map(r => `${fmtNum(+r.num_trades)} (${r.optimize_method.replace('gradient_descent','GD')})`);

            new Chart(document.getElementById(cid), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        { label: 'CRIF (s)', data: deduped.map(r => +r.crif_time_sec), backgroundColor: '#2563eb', borderRadius: 2 },
                        { label: 'SIMM (s)', data: deduped.map(r => +r.simm_time_sec), backgroundColor: '#8b5cf6', borderRadius: 2 },
                        { label: 'Gradient (s)', data: deduped.map(r => +r.im_sens_time_sec), backgroundColor: '#06b6d4', borderRadius: 2 },
                        { label: 'Optimizer (s)', data: deduped.map(r => +r.optimize_time_sec || 0), backgroundColor: '#22c55e', borderRadius: 2 },
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#7a8baa' } } },
                    scales: {
                        x: { stacked: true, ticks: { color: '#7a8baa', maxRotation: 45 }, grid: { color: 'rgba(36,48,80,0.5)' } },
                        y: { stacked: true, ticks: { color: '#7a8baa' }, grid: { color: 'rgba(36,48,80,0.5)' }, title: { display: true, text: 'Time (seconds)', color: '#7a8baa' } }
                    }
                }
            });
        }
    }
}

// ====================================================================
// Boot
// ====================================================================
animateCounters();
animatePipeline();
renderMethodComparison();
tabLoaded.methodology = true;
</script>
</body>
</html>
